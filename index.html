<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Jakcy’s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jakcy’s Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jakcy’s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Jakcy’s Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jakcy’s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">第一个博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/19/ReactNative原理详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/19/ReactNative原理详解/" itemprop="url">
                  ReactNative原理详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-19T17:27:31+08:00">
                2017-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>背景介绍：iOS APP审核周期长，通过简易的JSON配置能够去渲染不同的界面，进而实现动态页面的配置</p>
</blockquote>
<h1 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h1><p>React Native是前端和移动端的融合</p>
<h2 id="融合"><a href="#融合" class="headerlink" title="融合"></a>融合</h2><p>移动端通过 JSON 文件传递信息的不足之处：只能传递配置信息，无法表达逻辑。从本质上讲，这是因为 JSON 毕竟只是纯文本，它缺乏像编程语言那样的运行能力。</p>
<p>而 React 在前端取得突破性成功以后，JavaScript 布道者们开始试图一统三端。他们利用了移动平台能够运行 JavaScript 代码的能力，并且发挥了 JavaScript 不仅仅可以传递配置信息，还可以表达逻辑信息的优点。</p>
<p>当痛点遇上特点，两者一拍即合，于是乎：</p>
<blockquote>
<p>一个基于 JavaScript，具备动态配置能力，面向前端开发者的移动端开发框架，React Native，诞生了！</p>
</blockquote>
<h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>React Native 不是黑科技，我们写的代码总是以一种非常合理，可以解释的方式的运行着，只是绝大多数人没有理解而已。接下来我以 iOS 平台为例，简单的解释一下 React Native 的原理。</p>
<p>首先要明白的一点是，即使使用了 React Native，我们依然需要 UIKit 等框架，调用的是 Objective-C 代码。总之，JavaScript 只是辅助，它只是提供了配置信息和逻辑的处理结果。React Native 与 Hybrid 完全没有关系，它只不过是以 JavaScript 的形式告诉 Objective-C 该执行什么代码。</p>
<p>其次，React Native 能够运行起来，全靠 Objective-C 和 JavaScript 的交互。对于没有接触过 JavaScript 的人来说，非常有必要理解 JavaScript 代码如何被执行。</p>
<p> C 系列的语言，经过编译，链接等操作后，会得到一个二进制格式的可执行文，所谓的运行程序，其实是运行这个二进制程序。</p>
<p> 苹果提供了一个叫做 JavaScript Core 的框架，这是一个 JavaScript 引擎。通过下面这段代码可以简单的感受一下 Objective-C 如何调用 JavaScript 代码：</p>
<pre><code> JSContext *context = [[JSContext alloc] init];
JSValue *jsVal = [context evaluateScript:@&quot;21+7&quot;];
int iVal = [jsVal toInt32];
</code></pre><p>JavaScript 是一种单线程的语言，它不具备自运行的能力，因此总是被动调用。很多介绍 React Native 的文章都会提到 “JavaScript 线程” 的概念，实际上，它表示的是 Objective-C 创建了一个单独的线程，这个线程只用于执行 JavaScript 代码，而且 JavaScript 代码只会在这个线程中执行。</p>
<h1 id="Objective-C-与-JavaScript-交互"><a href="#Objective-C-与-JavaScript-交互" class="headerlink" title="Objective-C 与 JavaScript 交互"></a>Objective-C 与 JavaScript 交互</h1><p>提到 Objective-C 与 JavaScript 的交互，不得不推荐 bang神的这篇文章：<a href="http://blog.cnbang.net/tech/2698/" target="_blank" rel="external">React Native通信机制详解</a> 。虽然其中不少细节都已经过时，但是整体的思路值得学习。</p>
<p>本节主要分析 Objective-C 与 JavaScript 交互时的整理逻辑与流程，下一节将通过源码来分析具体原理。</p>
<h2 id="JavaScript-调用-Objective-C"><a href="#JavaScript-调用-Objective-C" class="headerlink" title="JavaScript 调用 Objective-C"></a>JavaScript 调用 Objective-C</h2><p>由于 JavaScript Core 是一个面向 Objective-C 的框架，在 Objective-C 这一端，我们对 JavaScript 上下文知根知底，可以很容易的获取到对象，方法等各种信息，当然也包括调用 JavaScript 函数。</p>
<p>真正复杂的问题在于，JavaScript 不知道 Objective-C 有哪些方法可以调用。</p>
<p>React Native 解决这个问题的方案是在 Objective-C 和 JavaScript 两端都保存了一份配置表，里面标记了所有 Objective-C 暴露给 JavaScript 的模块和方法。这样，无论是哪一方调用另一方的方法，实际上传递的数据只有 ModuleId、MethodId 和 Arguments 这三个元素，它们分别表示类、方法和方法参数，当 Objective-C 接收到这三个值后，就可以通过 runtime 唯一确定要调用的是哪个函数，然后调用这个函数。</p>
<p>上述解决方案只是一个抽象概念，可能与实际的解决方案有微小差异，比如实际上 Objective-C 这一端，并没有直接保存这个模块配置表。具体实现将在下一节中随着源码一起分析。</p>
<h2 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h2><p>既然说到函数互调，那么就不得不提到回调了。对于 Objective-C 来说，执行完 JavaScript 代码再执行 Objective-C 回调毫无难度，难点依然在于 JavaScript 代码调用 Objective-C 之后，如何在 Objective-C 的代码中，回调执行 JavaScript 代码。</p>
<p>目前 React Native 的做法是：在 JavaScript 调用 Objective-C 代码时，注册要回调的 Block，并且把 BlockId 作为参数发送给 Objective-C，Objective-C 收到参数时会创建 Block，调用完 Objective-C 函数后就会执行这个刚刚创建的 Block。</p>
<p>Objective-C 会向 Block 中传入参数和 BlockId，然后在 Block 内部调用 JavaScript 的方法，随后 JavaScript 查找到当时注册的 Block 并执行。</p>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="https://github.com/jackytianhappy/ImgSource/blob/master/ReactNative%E5%8E%9F%E7%90%86.png?raw=true" alt="Alta"></p>
<h1 id="React-Native-源码分析"><a href="#React-Native-源码分析" class="headerlink" title="React Native 源码分析"></a>React Native 源码分析</h1><p>要想深入理解 React Native 的工作原理，有两个部分有必要阅读一下，分别是初始化阶段和方法调用阶段。</p>
<h2 id="初始化React-Native"><a href="#初始化React-Native" class="headerlink" title="初始化React Native"></a>初始化React Native</h2><p>每个项目都有一个入口，然后进行初始化操作，React Native 也不例外。一个不含 Objective-C 代码的项目留给我们的唯一线索就是位于 AppDelegate 文件中的代码：</p>
<pre><code>RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation moduleName:@&quot;PropertyFinder&quot; initialProperties:nil launchOptions:launchOptions];    
</code></pre><p>用户能看到的一切内容都来源于这个 RootView，所有的初始化工作也都在这个方法内完成。</p>
<p>在这个方法内部，在创建 RootView 之前，React Native 实际上先创建了一个 Bridge 对象。它是 Objective-C 与 JavaScript 交互的桥梁，后续的方法交互完全依赖于它，而整个初始化过程的最终目的其实也就是创建这个桥梁对象。</p>
<p>初始化方法的核心是 setUp 方法，而 setUp 方法的主要任务则是创建 BatchedBridge。</p>
<p>BatchedBridge 的作用是批量读取 JavaScript 对 Objective-C 的方法调用，同时它内部持有一个 JavaScriptExecutor，顾名思义，这个对象用来执行 JavaScript 代码。</p>
<p>创建 BatchedBridge 的关键是 start 方法，它可以分为五个步骤：</p>
<ol>
<li>读取 JavaScript 源码</li>
<li>初始化模块信息</li>
<li>初始化 JavaScript 代码的执行器，即 RCTJSCExecutor 对象</li>
<li>生成模块列表并写入 JavaScript 端</li>
<li>执行 JavaScript 源码</li>
</ol>
<h3 id="读取-JavaScript-源码"><a href="#读取-JavaScript-源码" class="headerlink" title="读取 JavaScript 源码"></a>读取 JavaScript 源码</h3><p>这一部分的具体代码实现没有太大的讨论意义。我们只要明白，JavaScript 的代码是在 Objective-C 提供的环境下运行的，所以第一步就是把 JavaScript 加载进内存中，对于一个空的项目来说，所有的 JavaScript 代码大约占用 1.5 Mb 的内存空间。</p>
<p>需要说明的是，在这一步中，JSX 代码已经被转化成原生的 JavaScript 代码。</p>
<h3 id="初始化模块信息"><a href="#初始化模块信息" class="headerlink" title="初始化模块信息"></a>初始化模块信息</h3><p>这一步在方法 initModulesWithDispatchGroup: 中实现，主要任务是找到所有需要暴露给 JavaScript 的类。每一个需要暴露给 JavaScript 的类(也成为 Module，以下不作区分)都会标记一个宏：RCT_EXPORT_MODULE，这个宏的具体实现并不复杂：</p>
<pre><code>#define RCT_EXPORT_MODULE(js_name) \
RCT_EXTERN void RCTRegisterModule(Class); \
+ (NSString *)moduleName { return @#js_name; } \
+ (void)load { RCTRegisterModule(self); }
</code></pre><p>这样，这个类在 load 方法中就会调用 RCTRegisterModule 方法注册自己：</p>
<pre><code>    void RCTRegisterModule(Class moduleClass)
{
  static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{
    RCTModuleClasses = [NSMutableArray new];
  });

  [RCTModuleClasses addObject:moduleClass];
}
</code></pre><p>因此，React Native 可以通过 RCTModuleClasses 拿到所有暴露给 JavaScript 的类。下一步操作是遍历这个数组，然后生成 RCTModuleData 对象：</p>
<pre><code>for (Class moduleClass in RCTGetModuleClasses()) {
    RCTModuleData *moduleData = [[RCTModuleData alloc]initWithModuleClass:moduleClass                                                                      bridge:self];
    [moduleClassesByID addObject:moduleClass];
    [moduleDataByID addObject:moduleData];
}
</code></pre><p>可以想见，RCTModuleData 对象是模块配置表的主要组成部分。如果把模块配置表想象成一个数组，那么每一个元素就是一个 RCTModuleData 对象。</p>
<p><a href="http://www.jianshu.com/p/978c4bd3a759" target="_blank" rel="external">参见原文地址</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/18/WKWebview和UIWebView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/18/WKWebview和UIWebView/" itemprop="url">
                  WKWebview和UIWebView
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-18T18:10:15+08:00">
                2017-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>开发App的过程中，常常会遇到在App内部加载网页，通常用UIWebView加载。加载速度慢，占用内存多，优化困难。如果加载网页多，还可能因为过量占用内存而给系统kill掉。各种优化的方法效果也不那么明显</p>
</blockquote>
<p>iOS8以后，苹果推出了新框架Wekkit，提供了替换UIWebView的组件WKWebView。各种UIWebView的问题没有了，速度更快了，占用内存少了，一句话，WKWebView是App内部加载网页的最佳选择！</p>
<p>WKWebView的特性：</p>
<ol>
<li>在性能、稳定性、功能方面有很大提升（最直观的体现就是加载网页是占用的内存，模拟器加载百度与开源中国网站时，WKWebView占用23M，而UIWebView占用85M）；</li>
<li>允许JavaScript的Nitro库加载并使用（UIWebView中限制）；</li>
<li>支持了更多的HTML5特性；</li>
<li>高达60fps的滚动刷新率以及内置手势；</li>
<li>将UIWebViewDelegate与UIWebView重构成了14类与3个协议（查看苹果官方文档）；</li>
</ol>
<p>从以下几个方面说下WKWebView的基本用法：</p>
<ol>
<li>加载网页</li>
<li>加载的状态回调</li>
<li>新的WKUIDelegate协议</li>
<li>动态加载并运行js代码</li>
<li>webView执行js代码</li>
<li>js调用App注册过的方法</li>
</ol>
<h2 id="UIWebView和WKWebView的比较和选择"><a href="#UIWebView和WKWebView的比较和选择" class="headerlink" title="UIWebView和WKWebView的比较和选择"></a>UIWebView和WKWebView的比较和选择</h2><p>WKWebView是苹果在WWDC2014发布会中发布IOS8的时候公布WebKit时候使用的新型的H5容器。它与UIWebView相比较，拥有更快的加载速度和性能，更低的内存占用。将UIWebViewDelegate和UIWebView重构成了14个类，3个协议，可以让开发者进行更加细致的配置。</p>
<p>但是他有一个最致命的缺陷，就是WKWebView的请求不能被NSURLProtocol截获。而我们团队开发的app中对于H5容器最佳的优化点主要就在于使用NSURLProtocol技术对于H5进行离线包的处理和H5的图片和Native的图片公用一套缓存的技术。因为该问题的存在，目前我们团队还没有使用WKWebView代替UIWebVIew。</p>
<h2 id="UIWebView的基本用法"><a href="#UIWebView的基本用法" class="headerlink" title="UIWebView的基本用法"></a>UIWebView的基本用法</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code>UIWebView *webView = [[UIWebView alloc] initWithFrame:self.view.bounds];
webView.delegate = self;
[self.view addSubview:webView];    //网络地址
NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.taobao.com&quot;];    NSURLRequest *request = [NSURLRequest requestWithURL:url];
[webView loadRequest:request];    
</code></pre><h3 id="UIWebViewDelegate常用的代理方法"><a href="#UIWebViewDelegate常用的代理方法" class="headerlink" title="UIWebViewDelegate常用的代理方法"></a>UIWebViewDelegate常用的代理方法</h3><pre><code>- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;//进行加载前的预判断，如果返回YES，则会进入后续流程（StartLoad,FinishLoad）。如果返回NO，这不会进入后续流程。
- (void)webViewDidStartLoad:(UIWebView *)webView;//开始加载网页
- (void)webViewDidFinishLoad:(UIWebView *)webView;//加载完成
- (void)webView:(UIWebView *)webView didFailLoadWithError:(nullable NSError *)error;//加载失败
</code></pre><h3 id="Native调用js中方法"><a href="#Native调用js中方法" class="headerlink" title="Native调用js中方法"></a>Native调用js中方法</h3><p>我们可以调用- (nullable NSString )stringByEvaluatingJavaScriptFromString:(NSString )script;函数进行js调用。</p>
<pre><code>[webView stringByEvaluatingJavaScriptFromString:@&quot;hello()&quot;];
[webView stringByEvaluatingJavaScriptFromString:@&quot;helloWithName(&apos;jack&apos;)&quot;];
</code></pre><h3 id="JS中调用Naitve的方法"><a href="#JS中调用Naitve的方法" class="headerlink" title="JS中调用Naitve的方法"></a>JS中调用Naitve的方法</h3><p>具体让js通知native进行方法调用，我们可以让js产生一个特殊的请求。可以让Native代码可以拦截到，而且不然用户察觉。业界一般的实现方案是在网页中加载一个隐藏的iframe来实现该功能。通过将iframe的src指定为一个特殊的URL，实现在- (BOOL)webView:(UIWebView )webView shouldStartLoadWithRequest:(NSURLRequest )request navigationType:(UIWebViewNavigationType)navigationType;方案中进行拦截处理。对应的js调用代码如下：</p>
<h2 id="WKWebView的基本用法"><a href="#WKWebView的基本用法" class="headerlink" title="WKWebView的基本用法"></a>WKWebView的基本用法</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><pre><code>WKWebView *webView = [[WKWebView alloc] initWithFrame:[UIScreen mainScreen].bounds];    NSURL *url = [NSURL URLWithString:@&quot;http://www.taobao.com&quot;];    NSURLRequest *request = [NSURLRequest requestWithURL:url];
[webView loadRequest:request];
[self.view addSubview:webView];
</code></pre><h3 id="常用代理方法"><a href="#常用代理方法" class="headerlink" title="常用代理方法"></a>常用代理方法</h3><pre><code>/**
 *  根据webView、navigationAction相关信息决定这次跳转是否可以继续进行,这些信息包含HTTP发送请求，如头部包含User-Agent,Accept,refer
 *  在发送请求之前，决定是否跳转的代理
 *  @param webView
 *  @param navigationAction
 *  @param decisionHandler
 */- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler{
    decisionHandler(WKNavigationActionPolicyAllow);
}/**
 *  这个代理方法表示当客户端收到服务器的响应头，根据response相关信息，可以决定这次跳转是否可以继续进行。
 *  在收到响应后，决定是否跳转的代理
 *  @param webView
 *  @param navigationResponse
 *  @param decisionHandler
 */- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler{
    decisionHandler(WKNavigationResponsePolicyAllow);
}/**
 *  准备加载页面。等同于UIWebViewDelegate: - webView:shouldStartLoadWithRequest:navigationType
 *
 *  @param webView
 *  @param navigation
 */- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation{
}/**
 *  这个代理是服务器redirect时调用
 *  接收到服务器跳转请求的代理
 *  @param webView
 *  @param navigation
 */- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation{

}

- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error{

}/**
 *  内容开始加载. 等同于UIWebViewDelegate: - webViewDidStartLoad:
 *
 *  @param webView
 *  @param navigation
 */- (void)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation{

}/**
 *  页面加载完成。 等同于UIWebViewDelegate: - webViewDidFinishLoad:
 *
 *  @param webView
 *  @param navigation
 */- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation{

}/**
 *  页面加载失败。 等同于UIWebViewDelegate: - webView:didFailLoadWithError:
 *
 *  @param webView
 *  @param navigation
 *  @param error      
 */- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error{

}

- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView NS_AVAILABLE(10_11, 9_0){

}/*
 我们看看WKUIDelegate的几个代理方法，虽然不是必须实现的，但是如果我们的页面中有调用了js的alert、confirm、prompt方法，我们应该实现下面这几个代理方法，然后在原来这里调用native的弹出窗，因为使用WKWebView后，HTML中的alert、confirm、prompt方法调用是不会再弹出窗口了，只是转化成ios的native回调代理方法
 */#pragma mark - WKUIDelegate- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler{    UIAlertController *alertView = [UIAlertController alertControllerWithTitle:@&quot;h5Container&quot; message:message preferredStyle:UIAlertControllerStyleAlert];//    [alertView addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) {//        textField.textColor = [UIColor redColor];//    }];
    [alertView addAction:[UIAlertAction actionWithTitle:@&quot;我很确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        completionHandler();
    }]];
    [self presentViewController:alertView animated:YES completion:nil];
}
</code></pre><h3 id="Native调用JS中的方法"><a href="#Native调用JS中的方法" class="headerlink" title="Native调用JS中的方法"></a>Native调用JS中的方法</h3><p>WKWebView提供的调用js代码的函数是：</p>
<pre><code>- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ __nullable)(__nullable id, NSError * __nullable error))completionHandler;
</code></pre><p>比如我们在加载的HTML文件中有如下js代码：</p>
<pre><code>function hello(){
alert(&quot;你好！&quot;);
}function helloWithName(name){
alert(name + &quot;，你好！&quot;);
}
</code></pre><p>我们可以调用如下代码进行js的调用</p>
<pre><code>[_wkView evaluateJavaScript:@&quot;hello()&quot; completionHandler:^(id item, NSError * error) {
</code></pre><p>}];</p>
<pre><code>[_wkView evaluateJavaScript:@&quot;helloWithName(&apos;jack&apos;)&quot;     completionHandler:^(id item, NSError *error) {

    }];
</code></pre><p>同UIWebView一样，我们也可以通过字符串的形式进行js调用。</p>
<pre><code>NSString *jsString = @&quot;function sayHello(){ \
                                alert(&apos;jack11&apos;)   \
                            }                   \
                           sayHello()&quot;;
[_wkView evaluateJavaScript:jsString completionHandler:^(id item, NSError *error) {

}];

jsString = @&quot; var p = document.createElement(&apos;p&apos;); \
p.innerText = &apos;New Line&apos;;            \
document.body.appendChild(p);        \
&quot;;
[_wkView evaluateJavaScript:jsString completionHandler:^(id item, NSError *error) {

}];
</code></pre><h3 id="JS中调用Naitve的方法-1"><a href="#JS中调用Naitve的方法-1" class="headerlink" title="JS中调用Naitve的方法"></a>JS中调用Naitve的方法</h3><p>除了和UIWebView加载一个隐藏的ifame之外，WKWebView自身还提供了一套js调用native的规范。</p>
<p>我们可以在初始化WKWebView的时候，给他设置一个config参数。</p>
<pre><code>//高端配置
//创建配置
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];    //创建UserContentController(提供javaScript向webView发送消息的方法)
WKUserContentController *userContent = [[WKUserContentController alloc] init];    //添加消息处理，注意：self指代的是需要遵守WKScriptMessageHandler协议，结束时需要移除
[userContent addScriptMessageHandler:self name:@&quot;NativeMethod&quot;];    //将UserContentController设置到配置文件中
config.userContentController = userContent;    //高端的自定义配置创建WKWebView
_wkView = [[YXWKView alloc] initWithFrame:self.view.bounds configuration:config];    NSURL *url = [NSURL URLWithString:@&quot;http://localhost:8080/myDiary/index.html&quot;];    NSURLRequest *request = [NSURLRequest requestWithURL:url];
[_wkView loadRequest:request];
_wkView.UIDelegate = self;
_wkView.navigationDelegate = self;
[self.view addSubview:_wkView];
</code></pre><p> 我们在js可以通过NativeMethod这个Handler让js代码调用native。</p>
<p>比如在js代码中，我新增了一个方法</p>
<pre><code>function invokeNativeMethod(){        
window.webkit.messageHandlers.NativeMethod.postMessage(&quot;我要调用native的方法&quot;);
}
</code></pre><p>触发以上方法的时候，会在native以下方法中进行拦截处理。</p>
<pre><code>- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message{    //这里就是使用高端配置，js调用native的处理地方。我们可以根据name和body，进行桥协议的处理。
    NSString *messageName = message.name;    
    if ([@&quot;NativeMethod&quot; isEqualToString:messageName]) {        
    id messageBody = message.body;        
    NSLog(@&quot;%@&quot;,messageBody);
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/12/多线程以及多线程锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/12/多线程以及多线程锁/" itemprop="url">
                  多线程以及多线程锁
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T17:25:30+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="多线程中常用的锁"><a href="#多线程中常用的锁" class="headerlink" title="多线程中常用的锁"></a>多线程中常用的锁</h1><h2 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h2><p>lock unlock</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h2><pre><code>- (void)getIamgeName:(int)index{
    NSString *imageName;
    @synchronized(self) {
        if (imageNames.count&gt;0) {
            imageName = [imageNames lastObject];
            [imageNames removeObject:imageName];
        }
    }
}    
</code></pre><h2 id="条件信号量dispatch-semaphore-t"><a href="#条件信号量dispatch-semaphore-t" class="headerlink" title="条件信号量dispatch_semaphore_t"></a>条件信号量dispatch_semaphore_t</h2><blockquote>
<p>GCD中信号量，也可以解决资源抢占问题,支持信号通知和信号等待。每当发送一个信号通知，则信号量+1；每当发送一个等待信号时信号量-1,；如果信号量为0则信号会处于等待状态，直到信号量大于0开始执行。</p>
</blockquote>
<h2 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h2><p>NSCondition同样实现了NSLocking协议，所以它和NSLock一样，也有NSLocking协议的lock和unlock方法，可以当做NSLock来使用解决线程同步问题，用法完全一样</p>
<h2 id="条件锁NSConditionLock"><a href="#条件锁NSConditionLock" class="headerlink" title="条件锁NSConditionLock"></a>条件锁NSConditionLock</h2><p>也有人说这是个互斥锁NSConditionLock同样实现了NSLocking协议，试验过程中发现性能很低</p>
<h2 id="递归锁NSRecursiveLock"><a href="#递归锁NSRecursiveLock" class="headerlink" title="递归锁NSRecursiveLock"></a>递归锁NSRecursiveLock</h2><p>有时候“加锁代码”中存在递归调用，递归开始前加锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁，这个时候可以使用递归锁来解决。使用递归锁可以在一个线程中反复获取锁而不造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被最终释放。</p>
<h2 id="NSDistributedLock"><a href="#NSDistributedLock" class="headerlink" title="NSDistributedLock"></a>NSDistributedLock</h2><p>NSDistributedLock是MAC开发中的跨进程的分布式锁，底层是用文件系统实现的互斥锁。NSDistributedLock没有实现NSLocking协议，所以没有lock方法，取而代之的是非阻塞的tryLock方法。</p>
<pre><code>NSDistributedLock *lock = [[NSDistributedLock alloc]             initWithPath:@&quot;/Users/mac/Desktop/lock.lock&quot;];
    while (![lock tryLock])
    {
        sleep(1);
    }

    //do something
    [lock unlock];
</code></pre><h2 id="互斥锁POSIX"><a href="#互斥锁POSIX" class="headerlink" title="互斥锁POSIX"></a>互斥锁POSIX</h2><p>POSIX和dispatch_semaphore_t很像，但是完全不同。POSIX是Unix/Linux平台上提供的一套条件互斥锁的API。<br>新建一个简单的POSIX互斥锁，引入头文件#import <pthread.h>声明并初始化一个pthread_mutex_t的结构。使用pthread_mutex_lock和pthread_mutex_unlock函数。调用pthread_mutex_destroy来释放该锁的数据结构。</pthread.h></p>
<h2 id="GCD线程阻断dispatch-barrier-async-dispatch-barrier-sync"><a href="#GCD线程阻断dispatch-barrier-async-dispatch-barrier-sync" class="headerlink" title="GCD线程阻断dispatch_barrier_async/dispatch_barrier_sync"></a>GCD线程阻断dispatch_barrier_async/dispatch_barrier_sync</h2><p>dispatch_barrier_async/dispatch_barrier_sync在一定的基础上也可以做线程同步，会在线程队列中打断其他线程执行当前任务，也就是说只有用在并发的线程队列中才会有效，因为串行队列本来就是一个一个的执行的，你打断执行一个和插入一个是一样的效果。两个的区别是是否等待任务执行完成。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/12/Block内存地址/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/12/Block内存地址/" itemprop="url">
                  __Block内存地址
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T15:47:10+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>为什么添加__block的外部变量在闭包内部能够被修改？</p>
</blockquote>
<pre><code>int a = 0;          //栈区
void (^foo)(void) = ^{ 
   NSlog(@&quot;%@&quot;,a);   //堆区
};
foo(); 
//这里，a的值被修改为1
</code></pre><p>需要修改a的值</p>
<pre><code>__block int a = 0;
NSLog(@&quot;定义前：%p&quot;, &amp;a);         //栈区
void (^foo)(void) = ^{
    a = 1;
    NSLog(@&quot;block内部：%p&quot;, &amp;a);    //堆区
};
NSLog(@&quot;定义后：%p&quot;, &amp;a);         //堆区
foo();
</code></pre><p>添加<strong>block之后，变量a会被拷贝到堆区，同时经过编译之后生成一个</strong>forwarding的指针，这个指针指向的变量原栈区，修改时，实际上是通过<strong>forwarding指针访问堆区的内容进行修改。这样实现了修改。不加</strong>block不允许修改的实际上是变量的在栈中的指针地址。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/12/iOS内存泄漏工具以及实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/12/iOS内存泄漏工具以及实现原理/" itemprop="url">
                  以及实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T14:25:31+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="检测原理或实现思路"><a href="#检测原理或实现思路" class="headerlink" title="检测原理或实现思路"></a>检测原理或实现思路</h1><blockquote>
<p>开源库 例如 HeapInspector-for-iOS 和 MSLeakHunter。</p>
</blockquote>
<p>HeapInspector-for-iOS 可以说是 Allocations 的改进。它通过 hook 掉 alloc，dealloc，retain，release 等方法，来记录对象的生命周期。具体的检测内存泄露的方法和原理，与 Instrument 的 Allocations 一致。然而它跟 Allocations 一样，存在的问题是，你需要一个个场景去重复的操作，还有检测不及时。</p>
<p>MSLeakHunter 就简单得多，它只检测 UIViewController 和 UIView，通过 hook 掉 UIViewController 的 -viewDidDisappear: 方法，并认为 -viewDidDisappear: 后，UIViewController 将很快被释放，如果 UIViewController 没有被释放，则打个建议日志。这种做法其实不是很好，-viewDidDisappear: 被调用可能是因为又 push 进来一个新的 ViewController，把当前的 ViewController 挡住了，所以可能有很多错误的建议，需要结合你实际的操作去具体地分析日志。</p>
<p>#MLeaksFinder原理<br>MLeaksFinder 一开始从 UIViewController 入手。我们知道，当一个 UIViewController 被 pop 或 dismiss 后，该 UIViewController 包括它的 view，view 的 subviews 等等将很快被释放（除非你把它设计成单例，或者持有它的强引用，但一般很少这样做）。于是，我们只需在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 UIViewController，它的 view，view 的 subviews 等等是否还存在。</p>
<p>具体的方法是，为基类 NSObject 添加一个方法 -willDealloc 方法，该方法的作用是，先用一个弱指针指向 self，并在一小段时间(3秒)后，通过这个弱指针调用 -assertNotDealloc，而 -assertNotDealloc 主要作用是直接中断言。</p>
<pre><code>- (BOOL)willDealloc {
    __weak id weakSelf = self;
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        [weakSelf assertNotDealloc];
    });
    return YES;
}
- (void)assertNotDealloc {
     NSAssert(NO, @“”);
}
</code></pre><p>这样，当我们认为某个对象应该要被释放了，在释放前调用这个方法，如果3秒后它被释放成功，weakSelf 就指向 nil，不会调用到 -assertNotDealloc 方法，也就不会中断言，如果它没被释放（泄露了），-assertNotDealloc 就会被调用中断言。这样，当一个 UIViewController 被 pop 或 dismiss 时（我们认为它应该要被释放了），我们遍历该 UIViewController 上的所有 view，依次调 -willDealloc，若3秒后没被释放，就会中断言。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/06/Runloop详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/06/Runloop详解/" itemprop="url">
                  Runloop详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-06T14:22:17+08:00">
                2017-04-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Runloop实现了自动释放，延迟回调，触摸事件，屏幕刷新等功能。</p>
</blockquote>
<h2 id="Runloop概念"><a href="#Runloop概念" class="headerlink" title="Runloop概念"></a>Runloop概念</h2><ol>
<li><p>NSRunLoop是iOS消息机制的处理模式:<br><br>NSRunLoop的主要作用：控制NSRunLoop里面线程的执行和休眠，在有事情做的时候使当前NSRunLoop控制的线程工作，没有事情做让当前NSRunLoop的控制的线程休眠。</p>
</li>
<li><p>NSRunLoop 就是一直在循环检测，从线程start到线程end，检测inputsource(如点击，双击等操作)同步事件，检测timesource同步事件，检测到输入源会执行处理函数，首先会产生通知，corefunction向线程添加runloop observers来监听事件，意在监听事件发生时来做处理。</p>
</li>
<li><p>runloopmode是一个集合，包括监听：事件源，定时器，以及需通知的runloop observers,模式包括：<br></p>
<p> default模式：几乎包括所有输入源(除NSConnection) NSDefaultRunLoopMode模式</p>
<p> Modal模式：处理modal panels事件,需要等待处理的input source为modal panel时设置，比如NSSavePanel和NSOpenPanel。</p>
<p> connection模式：处理NSConnection事件，属于系统内部，用户基本不用</p>
<p> event tracking模式：使用该模式来处理用户界面相关的事件,例如在拖动loop或其他user interface tracking loops时处于此种模式下，在此模式下会限制输入事件的处理。例如，当手指按住UITableView拖动时就会处于此模式</p>
<p> common modes模式：这是一个伪模式，其为一组run loop mode的集合，将输入源加入此模式意味着在Common Modes中包含的所有模式下都可以处理。在Cocoa应用程序中，默认情况下Common Modes包含default modes,modal modes,event Tracking modes, 可使用CFRunLoopAddCommonMode方法向Common Modes中添加自定义modes。</p>
</li>
</ol>
<p>注意这个并不是一个特定的mode，而是一个mode的集合，而runloop必须运行在一个特定的mode下。</p>
<ol>
<li>每次运行一个run loop，你指定（显式或隐式）run loop的运行模式。当相应的模式传递给run loop时，只有与该模式对应的 input sources才被监控并允许run loop对事件进行处理（与此类似，也只有与该模式对应的observers才会被通知）</li>
<li>子线程中的NSRunLoop需要手动启动，在子线程中使用timer要启动NSRunLoop。</li>
</ol>
<p><a href="http://blog.wangruofeng007.com/blog/2016/01/12/runloopxiang-jie/" target="_blank" rel="external">这里有篇不错的文章</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/05/iOS中图片的解压缩详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/05/iOS中图片的解压缩详解/" itemprop="url">
                  性能优化-iOS中图片的解压缩
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-05T16:20:54+08:00">
                2017-04-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="图片加载的工作流"><a href="#图片加载的工作流" class="headerlink" title="图片加载的工作流"></a>图片加载的工作流</h2><ol>
<li>假设我们使用 +imageWithContentsOfFile: 方法从磁盘中加载一张图片，这个时候的图片并没有解压缩；</li>
<li>然后将生成的 UIImage 赋值给 UIImageView ；</li>
<li>接着一个隐式的 CATransaction 捕获到了 UIImageView 图层树的变化；</li>
<li>在主线程的下一个 run loop 到来时，Core Animation 提交了这个隐式的 transaction ，这个过程可能会对图片进行 copy 操作，而受图片是否字节对齐等因素的影响，这个 copy 操作可能会涉及以下部分或全部步骤：<br><br> a. 分配内存缓冲区用于管理文件 IO 和解压缩操作<br><br> b. 将文件数据从磁盘读到内存中<br><br> c. 将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作<br><br> d. 最后 Core Animation 使用未压缩的位图数据渲染 UIImageView 的图层<br><br>图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。</li>
</ol>
<h2 id="为什么需要解压缩"><a href="#为什么需要解压缩" class="headerlink" title="为什么需要解压缩"></a>为什么需要解压缩</h2><p>图片的解压缩需要消耗大量的 CPU 时间，那么我们为什么还要对图片进行解压缩呢？是否可以不经过解压缩，而直接将图片显示到屏幕上呢？答案是否定的。要想弄明白这个问题，我们首先需要知道什么是位图：<br><br>位图：位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点。我们在应用中经常用到的 JPEG 和 PNG 图片就是位图。下面，我们来看一个具体的例子，这是一张 PNG 图片，像素为 30 × 30 ，文件大小为 843B ：<br><br>图片设置方式：</p>
<pre><code>UIImage *image = [UIImage imageNamed:@&quot;check_green&quot;];
CFDataRef rawData = CGDataProviderCopyData(CGImageGetDataProvider(image.CGImage));
</code></pre><p>获取到的图片原始数据为，大小为3600B</p>
<pre><code>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
01020102 032c023c 0567048c 078d06bf 08a006d9 09b307f3 09b307f3 08a006d9 078d06bf
0567048c 032c023c 01020102 00000000 00000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000 01060108 05570476 09ab07e9 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff
09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09ab07e9 05570476 01060108 00000000
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 033d0353 08a607e2 09bb07ff 09bb07ff 09bb07ff 09bb07ff
...
09bb07ff 09bb07ff 09bb07ff 09bb07ff 08a607e2 033d0353 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000 01060108 05570476 09ab07e9 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff
09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09ab07e9 05570476 01060108 00000000
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000000 00000000 01020102 032c023c 0567048c
078d06bf 08a006d9 09b307f3 09b307f3 08a006d9 078d06bf 0567048c 032c023c 01020102
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
</code></pre><p>这张文件大小为 843B 的 PNG 图片解压缩后的大小是 3600B ，是原始文件大小的 4.27 倍。那么这个 3600B 是怎么得来的呢？与图片的文件大小或者像素有什么必然的联系吗？事实上，解压缩后的图片大小与原始文件大小之间没有任何关系，而只与图片的像素有关：</p>
<pre><code>解压缩后的图片大小 = 图片的像素宽 30 * 图片的像素高 30 * 每个像素所占的字节数 4
</code></pre><p>事实上，<b>不管是 JPEG 还是 PNG 图片，都是一种压缩的位图图形格式。</b>只不过 PNG 图片是无损压缩，并且支持 alpha 通道，而 JPEG 图片则是有损压缩，可以指定 0-100% 的压缩比。值得一提的是，在苹果的 SDK 中专门提供了两个函数用来生成 PNG 和 JPEG 图片：</p>
<pre><code>// return image as PNG. May return nil if image has no CGImageRef or invalid bitmap format
UIKIT_EXTERN NSData * __nullable UIImagePNGRepresentation(UIImage * __nonnull image);

// return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)                           
UIKIT_EXTERN NSData * __nullable UIImageJPEGRepresentation(UIImage * __nonnull image, CGFloat compressionQuality);
</code></pre><p>在将磁盘中的图片渲染到屏幕之前，必须先要得到图片的原始像素数据，才能执行后续的绘制操作，这就是为什么需要对图片解压缩的原因。</p>
<h2 id="强制解压缩的原理"><a href="#强制解压缩的原理" class="headerlink" title="强制解压缩的原理"></a>强制解压缩的原理</h2><p>图片的解压缩不可避免，而我们也不想让它在主线程执行，影响我们应用的响应性，那么是否有比较好的解决方案呢？答案是肯定的。<br></p>
<p>前面已经提到了，当未解压缩的图片将要渲染到屏幕时，系统会在主线程对图片进行解压缩，而如果图片已经解压缩了，系统就不会再对图片进行解压缩。因此，也就有了业内的解决方案，在子线程提前对图片进行强制解压缩。<br></p>
<p>而强制解压缩的原理就是对图片进行重新绘制，得到一张新的解压缩后的位图。其中，用到的最核心的函数是 CGBitmapContextCreate ：<br></p>
<pre><code>/* Create a bitmap context. The context draws into a bitmap which is `width&apos;
   pixels wide and `height&apos; pixels high. The number of components for each
   pixel is specified by `space&apos;, which may also specify a destination color
   profile. The number of bits for each component of a pixel is specified by
   `bitsPerComponent&apos;. The number of bytes per pixel is equal to
   `(bitsPerComponent * number of components + 7)/8&apos;. Each row of the bitmap
   consists of `bytesPerRow&apos; bytes, which must be at least `width * bytes
   per pixel&apos; bytes; in addition, `bytesPerRow&apos; must be an integer multiple
   of the number of bytes per pixel. `data&apos;, if non-NULL, points to a block
   of memory at least `bytesPerRow * height&apos; bytes. If `data&apos; is NULL, the
   data for context is allocated automatically and freed when the context is
   deallocated. `bitmapInfo&apos; specifies whether the bitmap should contain an
   alpha channel and how it&apos;s to be generated, along with whether the
   components are floating-point or integer. */
CG_EXTERN CGContextRef __nullable CGBitmapContextCreate(void * __nullable data,
    size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow,
    CGColorSpaceRef cg_nullable space, uint32_t bitmapInfo)
    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
</code></pre><p>这个函数用于创建一个位图上下文，用来绘制一张宽 width 像素，高 height 像素的位图。这个函数的注释比较长，参数也比较难理解，但是先别着急，我们先来了解下相关的知识，然后再回过头来理解这些参数，就会比较简单了。</p>
<h3 id="Pixel-Format"><a href="#Pixel-Format" class="headerlink" title="Pixel Format"></a>Pixel Format</h3><p>位图其实就是一个像素数组，而像素格式则是用来描述每个像素的组成格式，它包括以下信息：</p>
<ol>
<li>Bits per component ：一个像素中每个独立的颜色分量使用的 bit 数；</li>
<li>Bits per pixel ：一个像素使用的总 bit 数；</li>
<li>Bytes per row ：位图中的每一行使用的字节数。</li>
</ol>
<p>有一点需要注意的是，对于位图来说，像素格式并不是随意组合的，目前只支持以下有限的 17 种特定组合：<br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/Supported%20Pixel%20Formats.png?raw=true" alt="Alta Text"></p>
<p>从上图可知，对于 iOS 来说，只支持 8 种像素格式。其中颜色空间为 Null 的 1 种，Gray 的 2 种，RGB 的 5 种，CMYK 的 0 种。换句话说，iOS 并不支持 CMYK 的颜色空间。另外，在表格的第 2 列中，除了像素格式外，还指定了 bitmap information constant ，我们在后面会详细介绍。</p>
<h3 id="Color-and-Color-Spaces"><a href="#Color-and-Color-Spaces" class="headerlink" title="Color and Color Spaces"></a>Color and Color Spaces</h3><p>上面我们提到了颜色空间，那么什么是颜色空间呢？它跟颜色有什么关系呢？在 Quartz 中，一个颜色是由一组值来表示的，比如 0, 0, 1 。而颜色空间则是用来说明如何解析这些值的，离开了颜色空间，它们将变得毫无意义。<br></p>
<p>如果不知道颜色空间，那么我们根本无法知道这些值所代表的颜色。比如 0, 0, 1 在 RGB 下代表蓝色，而在 BGR 下则代表的是红色。在 RGB 和 BGR 两种颜色空间下，绿色是相同的，而红色和蓝色则相互对调了。因此，对于同一张图片，使用 RGB 和 BGR 两种颜色空间可能会得到两种不一样的效果<br></p>
<h3 id="Color-Spaces-and-Bitmap-Layout"><a href="#Color-Spaces-and-Bitmap-Layout" class="headerlink" title="Color Spaces and Bitmap Layout"></a>Color Spaces and Bitmap Layout</h3><p>像素格式是用来描述每个像素的组成格式的，比如每个像素使用的总 bit 数。而要想确保 Quartz 能够正确地解析这些 bit 所代表的含义，我们还需要提供位图的布局信息 CGBitmapInfo ：</p>
<pre><code>typedef CF_OPTIONS(uint32_t, CGBitmapInfo) {
    kCGBitmapAlphaInfoMask = 0x1F,

    kCGBitmapFloatInfoMask = 0xF00,
    kCGBitmapFloatComponents = (1 &lt;&lt; 8),

    kCGBitmapByteOrderMask     = kCGImageByteOrderMask,
    kCGBitmapByteOrderDefault  = (0 &lt;&lt; 12),
    kCGBitmapByteOrder16Little = kCGImageByteOrder16Little,
    kCGBitmapByteOrder32Little = kCGImageByteOrder32Little,
    kCGBitmapByteOrder16Big    = kCGImageByteOrder16Big,
    kCGBitmapByteOrder32Big    = kCGImageByteOrder32Big
} CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
</code></pre><p>它主要提供了三个方面的布局信息：</p>
<ol>
<li>它主要提供了三个方面的布局信息：</li>
<li>颜色分量是否为浮点数；</li>
<li>像素格式的字节顺序。</li>
</ol>
<p>其中，alpha 的信息由枚举值 CGImageAlphaInfo 来表示：</p>
<pre><code>typedef CF_ENUM(uint32_t, CGImageAlphaInfo) {
    kCGImageAlphaNone,               /* For example, RGB. */
    kCGImageAlphaPremultipliedLast,  /* For example, premultiplied RGBA */
    kCGImageAlphaPremultipliedFirst, /* For example, premultiplied ARGB */
    kCGImageAlphaLast,               /* For example, non-premultiplied RGBA */
    kCGImageAlphaFirst,              /* For example, non-premultiplied ARGB */
    kCGImageAlphaNoneSkipLast,       /* For example, RBGX. */
    kCGImageAlphaNoneSkipFirst,      /* For example, XRGB. */
    kCGImageAlphaOnly                /* No color data, alpha data only */
};
</code></pre><p>上面的注释其实已经比较清楚了，它同样也提供了三个方面的 alpha 信息:</p>
<ol>
<li>是否包含 alpha ；</li>
<li>如果包含 alpha ，那么 alpha 信息所处的位置，在像素的最低有效位，比如 RGBA ，还是最高有效位，比如 ARGB ；</li>
<li>如果包含 alpha ，那么每个颜色分量是否已经乘以 alpha 的值，这种做法可以加速图片的渲染时间，因为它避免了渲染时的额外乘法运算。比如，对于 RGB 颜色空间，用已经乘以 alpha 的数据来渲染图片，每个像素都可以避免 3 次乘法运算，红色乘以 alpha ，绿色乘以 alpha 和蓝色乘以 alpha 。<br></li>
</ol>
<p>那么我们在解压缩图片的时候应该使用哪个值呢？根据<a href="http://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use" target="_blank" rel="external">Which CGImageAlphaInfo should we use</a>和官方文档中对 UIGraphicsBeginImageContextWithOptions 函数的讨论：<br></p>
<p>我们可以知道，当图片不包含 alpha 的时候使用 kCGImageAlphaNoneSkipFirst ，否则使用 kCGImageAlphaPremultipliedFirst 。另外，这里也提到了字节顺序应该使用 32 位的主机字节顺序 kCGBitmapByteOrder32Host ，而这个值具体是什么，我们后面再讨论。</p>
<p>至于颜色分量是否为浮点数，这个就比较简单了，直接逻辑或 kCGBitmapFloatComponents 就可以了。更详细的内容就不展开了，因为我们一般用不上这个值。</p>
<p>接下来，我们来简单地了解下像素格式的<a href="https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/ByteOrdering.html#//apple_ref/doc/uid/20001150-CJBEJBHH" target="_blank" rel="external">字节顺序</a>，它是由枚举值 <code>CGImageByteOrderInfo</code> 来表示的：</p>
<pre><code>typedef CF_ENUM(uint32_t, CGImageByteOrderInfo) {
    kCGImageByteOrderMask     = 0x7000,
    kCGImageByteOrder16Little = (1 &lt;&lt; 12),
    kCGImageByteOrder32Little = (2 &lt;&lt; 12),
    kCGImageByteOrder16Big    = (3 &lt;&lt; 12),
    kCGImageByteOrder32Big    = (4 &lt;&lt; 12)
} CG_AVAILABLE_STARTING(__MAC_10_12, __IPHONE_10_0);
</code></pre><p>它主要提供了两个方面的字节顺序信息：</p>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.B0.8F.E7.AB.AF.E5.BA.8F" target="_blank" rel="external">小端模式</a>还是<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.A4.A7.E7.AB.AF.E5.BA.8F" target="_blank" rel="external">大端模式</a>；</li>
<li>数据以 16 位还是 32 位为单位。</li>
</ol>
<p>对于 iPhone 来说，采用的是小端模式，但是为了保证应用的向后兼容性，我们可以使用系统提供的宏，来避免 <a href="https://en.wikipedia.org/wiki/Hard_coding" target="_blank" rel="external">Hardcoding</a></p>
<pre><code>#ifdef __BIG_ENDIAN__
    #define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Big
    #define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Big
#else /* Little endian. */
    #define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Little
    #define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Little
#endif
</code></pre><p>根据前面的讨论，我们知道字节顺序的值应该使用的是 32 位的主机字节顺序 <code>kCGBitmapByteOrder32Host</code> ，这样的话不管当前设备采用的是小端模式还是大端模式，字节顺序始终与其保持一致。</p>
<p>下面，我们来看一张图，它非常形象地展示了在使用 16 或 32 位像素格式的 CMYK 和 RGB 颜色空间下，一个像素是如何被表示的：<br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/pixel%20formats.png?raw=true" alt="Alta Text"></p>
<p>我们从图中可以看出，在 32 位像素格式下，每个颜色分量使用 8 位；而在 16 位像素格式下，每个颜色分量则使用 5 位。</p>
<p>好了，了解完这些相关知识后，我们再回过头来看看 <code>CGBitmapContextCreate</code> 函数中每个参数所代表的具体含义：</p>
<ol>
<li><code>data</code> ：如果不为 <code>NULL</code> ，那么它应该指向一块大小至少为 <code>bytesPerRow * height</code> 字节的内存；如果 为 <code>NULL</code> ，那么系统就会为我们自动分配和释放所需的内存，所以一般指定 <code>NULL</code> 即可；</li>
<li><code>width</code> 和 <code>height</code> ：位图的宽度和高度，分别赋值为图片的像素宽度和像素高度即可；</li>
<li><code>bitsPerComponent</code> ：像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可；</li>
<li><code>bytesPerRow</code> ：位图的每一行使用的字节数，大小至少为 <code>width * bytes per pixel</code> 字节。有意思的是，当我们指定<code>0</code> 时，系统不仅会为我们自动计算，而且还会进行 cache line alignment 的优化，更多信息可以查看 <a href="http://stackoverflow.com/questions/23790837/what-is-byte-alignment-cache-line-alignment-for-core-animation-why-it-matters" target="_blank" rel="external">what is byte alignment (cache line alignment) for Core Animation? Why it matters?</a> 和 <a href="http://stackoverflow.com/questions/15935074/why-is-my-images-bytes-per-row-more-than-its-bytes-per-pixel-times-its-width" target="_blank" rel="external">Why is my image’s Bytes per Row more than its Bytes per Pixel times its Width?</a> ，亲测可用；</li>
<li><code>space</code> ：就是我们前面提到的颜色空间，一般使用 RGB 即可；</li>
<li><code>bitmapInfo</code> ：就是我们前面提到的位图的布局信息</li>
</ol>
<h2 id="开源库的实现"><a href="#开源库的实现" class="headerlink" title="开源库的实现"></a>开源库的实现</h2><p>三个比较流行的开源库 <a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">YYKit</a> 、<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a> 和 <a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="external">FLAnimatedImage</a> 中，对图片的强制解压缩是如何实现的。</p>
<p> YYKit 中的相关代码，用于解压缩图片的函数 YYCGImageCreateDecodedCopy 存在于 YYImageCoder 类中，核心代码如下：</p>
<pre><code> CGImageRef YYCGImageCreateDecodedCopy(CGImageRef imageRef, BOOL decodeForDisplay) {
    ...

    if (decodeForDisplay) { // decode with redraw (may lose some precision)
        CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef) &amp; kCGBitmapAlphaInfoMask;

        BOOL hasAlpha = NO;
        if (alphaInfo == kCGImageAlphaPremultipliedLast ||
            alphaInfo == kCGImageAlphaPremultipliedFirst ||
            alphaInfo == kCGImageAlphaLast ||
            alphaInfo == kCGImageAlphaFirst) {
            hasAlpha = YES;
        }

        // BGRA8888 (premultiplied) or BGRX8888
        // same as UIGraphicsBeginImageContext() and -[UIView drawRect:]
        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;
        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;

        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);
        if (!context) return NULL;

        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); // decode
        CGImageRef newImage = CGBitmapContextCreateImage(context);
        CFRelease(context);

        return newImage;
    } else {
        ...
    }
}
</code></pre><p>它接受一个原始的位图参数 <code>imageRef</code> ，最终返回一个新的解压缩后的位图 <code>newImage</code> ，中间主要经过了以下三个步骤：<br></p>
<ol>
<li>使用 <code>CGBitmapContextCreate</code> 函数创建一个位图上下文；</li>
<li>使用 <code>CGContextDrawImage</code> 函数将原始位图绘制到上下文中；</li>
<li>使用 <code>CGBitmapContextCreateImage</code> 函数创建一张新的解压缩后的位图。</li>
</ol>
<p>事实上，SDWebImage 和 FLAnimatedImage 中对图片的解压缩过程与上述完全一致，只是传递给 <code>CGBitmapContextCreate</code> 函数的部分参数存在细微的差别，如下表所示：<br><img src="https://raw.githubusercontent.com/jackytianhappy/ImgSource/0619b8810cde373c9f061ad8843406f38285c56d/CGBitmapContextCreate.png" alt="Alta Text"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/01/http学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/01/http学习笔记/" itemprop="url">
                  http学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-01T15:42:34+08:00">
                2017-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>http的请求分成了三部分：请求行，请求头和请求正文<br><br></p>
<pre><code>POST /index.php HTTP/1.1
Host: localhost
User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-cn,zh;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Referer: http://localhost/
Content-Length：25
Content-Type：application/x-www-form-urlencoded
username=aa&amp;password=1234
</code></pre><h1 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h1><h2 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h2><p>请求行的格式为“方法+URL+协议/版本”,回车换行作为结尾，以空格分割。例如<br><br>POST /index.php HTTP/1.1<br><br>以上代码中“GET”代表请求方法，“//ndex.php”表示URI，“HTTP/1.1代表协议和协议的版本。<br><br>URL完整地指定了要访问的网络资源，通常只要给出相对于服务器的根目录的相对目录即可，因此总是以“/”开头，最后，协议版本声明了通信过程中使用HTTP的版本。   </p>
</blockquote>
<p>请求方法简介：<br></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>请求获取由 Request-URI 所标识的资源</td>
</tr>
<tr>
<td>POST</td>
<td>请求服务器接收在请求中封装的实体，并将其作为由 Request-Line 中Request-URL所标识的资源的一部分</td>
</tr>
<tr>
<td>HEAD</td>
<td>请求获取由 Request-URI 所标识的资源的响应消息报头</td>
</tr>
<tr>
<td>PUT</td>
<td>请求服务器存储一个资源，并用 Request-URI 作为其标识符</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除由 Request-URI 所标识的资源</td>
</tr>
<tr>
<td>TRACE</td>
<td>请求服务器回送到的请求信息，主要用于测试或诊断</td>
</tr>
<tr>
<td>CONNECT</td>
<td>保留将来使用</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>请求查询服务器的性能，或者查询与资源相关的选项和需求</td>
</tr>
</tbody>
</table>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>GET 方法用于获取由Request-URL所标识的资源的信息，常见的形式是：<br><br>GET Request-URI HTTP/1.1<br><br>GET方法是默认的HTTP请求方法，例如当我们通过在浏览器的地址栏中直接输入网址的方式去访问网页的时候，浏览器采用的就是 GET 方法向服务器获取资源。<br></p>
<p> 我们可以使用GET方法来提交表单数据，用GET方法提交的表单数据只经过了简单的编码，同时它将作为URL的一部分向服务器发送，因此，如果使用GET方法来提交表单数据就存在着安全隐患上。例如：<br><br>     Http://localhost/login.php?username=aa&amp;password=1234<br><br>    从上面的URL请求中，很容易就可以辩认出表单提交的内容。（？之后的内容）另外由于GET方法提交的数据是作为URL请求的一部分所以提交的数据量不能太大。这是因为浏览器对url的长度有限制<br><br>   各种浏览器也会对url的长度有所限制，下面是几种常见浏览器的url长度限制:(单位:字符)<br><br>      IE : 2803<br>    Firefox:65536<br>    Chrome:8182<br>    Safari:80000<br>    Opera:190000 </p>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>POST方法是GET方法的一个替代方法，它主要是向Web服务器提交表单数据，尤其是大批量的数据。 在请求头信息结束之后的两个回车换行之后（实际是空一行），就是表单提交的数据。如上面提到的post表单数据：<br><br> username=aa&amp;password=1234<br><br>    POST方法克服了GET方法的一些缺点。通过POST方法提交表单数据时，数据不是作为URL请求的一部分而是作为标准数据传送给Web服务器，这就克服了GET方法中的信息无法保密和数据量太小的缺点。因此，出于安全的考虑以及对用户隐私的尊重，通常表单提交时采用POST方法。<br><br>    从编程的角度来讲，如果用户通过GET方法提交数据，则数据存放在QUERY＿STRING环境变量中，而POST方法提交的数据则可以从标准输入流中获取。<br></p>
<h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><ol>
<li>在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放在HTTP包的body中。</li>
<li>GET方式提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST则没有此限制。</li>
<li>安全性问题。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。</li>
<li>服务器取值方式不一样。GET方式取值，如php可以使用$_GET来取得变量的值，而POST方式通过$_POST来获取变量的值。</li>
</ol>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>HEAD 方法与 GET 方法几乎是相同的，它们的区别在于 HEAD 方法只是请求消息报头，而不是完整的内容。对于 HEAD 请求的回应部分来说，它的 HTTP 头部中包含的信息与通过 GET 请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到 Request-URI 所标识的资源的信息。这个方法通常被用于测试超链接的有效性，是否可以访问，以及最近是否更新。</p>
<h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><p>每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p>
<h3 id="Transport-头域"><a href="#Transport-头域" class="headerlink" title="Transport 头域"></a>Transport 头域</h3><h4 id="Connection："><a href="#Connection：" class="headerlink" title="Connection："></a>Connection：</h4><p>如果服务器看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接）,它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，服务器需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入 ByteArrayOutputStream，然后在正式写出内容之前计算它的大小；</p>
<h4 id="Host（发送请求时，该报头域是必需的"><a href="#Host（发送请求时，该报头域是必需的" class="headerlink" title="Host（发送请求时，该报头域是必需的)"></a>Host（发送请求时，该报头域是必需的)</h4><p>Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。<br><br>eg：<a href="http://；localhost/index.html" target="_blank" rel="external">http://；localhost/index.html</a><br><br>浏览器发送的请求消息中，就会包含Host请求报头域，如下：<br><br>Host：localhost<br><br>此处使用缺省端口号80，若指定了端口号8080，则变成：Host：localhost:8080<br></p>
<h3 id="Client-头域"><a href="#Client-头域" class="headerlink" title="Client 头域"></a>Client 头域</h3><h4 id="Accept："><a href="#Accept：" class="headerlink" title="Accept："></a>Accept：</h4><p>作用：浏览器可以接受的媒体类型（MIME类型）,</p>
<p>例如：  Accept: text/html  代表浏览器可以接受服务器回发的类型为 text/html  也就是我们常说的html文档, 如果服务器无法返回text/html类型的数据，服务器应该返回一个406错误(non acceptable)。</p>
<p>通配符 <em> 代表任意类型。例如  Accept: </em>/*  代表浏览器可以处理所有类型，(一般浏览器发给服务器都是发这个)</p>
<h4 id="Accept-Encoding："><a href="#Accept-Encoding：" class="headerlink" title="Accept-Encoding："></a>Accept-Encoding：</h4><p>作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是字符编码）;</p>
<p>例如： Accept-Encoding: gzip, deflate。Server能够向支持gzip/deflate的浏览器返回经gzip或者deflate编码的HTML页面。 许多情形下这可以减少5到10倍的下载时间，也节省带宽。</p>
<h4 id="Accept-Language："><a href="#Accept-Language：" class="headerlink" title="Accept-Language："></a>Accept-Language：</h4><p>作用： 浏览器申明自己接收的语言。 </p>
<p>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；</p>
<p>例如： Accept-Language:zh-cn 。如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。</p>
<h4 id="User-Agent："><a href="#User-Agent：" class="headerlink" title="User-Agent："></a>User-Agent：</h4><p>作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.</p>
<p>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上， 服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。</p>
<p>例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)</p>
<h4 id="Accept-Charset："><a href="#Accept-Charset：" class="headerlink" title="Accept-Charset："></a>Accept-Charset：</h4><p>作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）；</p>
<p>例如：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。</p>
<p>Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中；</p>
<p>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。</p>
<h3 id="Cookie-Login-头域"><a href="#Cookie-Login-头域" class="headerlink" title="Cookie/Login 头域"></a>Cookie/Login 头域</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h4><p>作用： 最重要的header, 将cookie的值发送给HTTP 服务器</p>
<h3 id="Entity头域"><a href="#Entity头域" class="headerlink" title="Entity头域"></a>Entity头域</h3><h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length:"></a>Content-Length:</h4><p>作用：发送给HTTP服务器数据的长度。即请求消息正文的长度；</p>
<p>例如： Content-Length: 38</p>
<h4 id="Content-Type："><a href="#Content-Type：" class="headerlink" title="Content-Type："></a>Content-Type：</h4><p>作用：</p>
<p>例如：Content-Type: application/x-www-form-urlencoded</p>
<h3 id="Miscellaneous-头域"><a href="#Miscellaneous-头域" class="headerlink" title="Miscellaneous 头域"></a>Miscellaneous 头域</h3><h4 id="Refer"><a href="#Refer" class="headerlink" title="Refer:"></a>Refer:</h4><p>作用： 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里， 他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问    他的网站。</p>
<p>例如: Referer:<a href="http://translate.google.cn/?hl=zh-cn&amp;tab=wT" target="_blank" rel="external">http://translate.google.cn/?hl=zh-cn&amp;tab=wT</a></p>
<h3 id="Cache-头域"><a href="#Cache-头域" class="headerlink" title="Cache 头域"></a>Cache 头域</h3><h4 id="If-Modified-Since："><a href="#If-Modified-Since：" class="headerlink" title="If-Modified-Since："></a>If-Modified-Since：</h4><p>作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。</p>
<p>例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT。</p>
<h4 id="If-Modified-Match："><a href="#If-Modified-Match：" class="headerlink" title="If-Modified-Match："></a>If-Modified-Match：</h4><p>作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag.  使用这样的机制将提高网站的性能</p>
<p>例如: If-None-Match: “03f2b33c0bfcc1:0”</p>
<h4 id="Pragma："><a href="#Pragma：" class="headerlink" title="Pragma："></a>Pragma：</h4><p>作用： 防止页面被缓存， 在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样</p>
<p>Pargma只有一个用法， 例如： Pragma: no-cache</p>
<p>注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control</p>
<h4 id="Cache-Control："><a href="#Cache-Control：" class="headerlink" title="Cache-Control："></a>Cache-Control：</h4><p>作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下</p>
<p>Cache-Control:Public   可以被任何缓存所缓存（）</p>
<p>Cache-Control:Private     内容只缓存到私有缓存中</p>
<p>Cache-Control:no-cache  所有内容都不会被缓存</p>
<h1 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h1><blockquote>
<p>响应也是由三部分祖成，状态行、消息报头、响应正文</p>
</blockquote>
<pre><code>在接收和解释请求消息后，服务器会返回一个 HTTP 响应消息。与 HTTP 请求类似，HTTP 响应也是由三个部分组成，分别是：状态行、消息报头和响应正文。如：

HTTP/1.1 200 OK
Date: Sun, 17 Mar 2013 08:12:54 GMT
Server: Apache/2.2.8 (Win32) PHP/5.2.5
X-Powered-By: PHP/5.2.5
Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/
Expires: Thu, 19 Nov 1981 08:52:00 GMT
Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0
Pragma: no-cache
Content-Length: 4393
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: text/html; charset=utf-8


&lt;html&gt;
&lt;head&gt;
&lt;title&gt;HTTP响应示例&lt;title&gt;
&lt;/head&gt;
&lt;body&gt;
Hello HTTP!
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h2><blockquote>
<p>组成由协议版本数字形式+状态代码+状态描述 元素之间已空格分开<br><br>HTTP-Version + Status-Code + Reason-Phrase CRLF</p>
</blockquote>
<p>常用状态码解析：</p>
<ol>
<li>1xx：指示信息——表示请求已经接受，继续处理</li>
<li>2xx：成功——表示请求已经被成功接收、理解、接受。</li>
<li>3xx：重定向——要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误——客户端请求有错误或请求无法实现</li>
<li>5xx：服务器端错误——服务器未能实现合法的请求。</li>
</ol>
<p>描述：</p>
<ol>
<li>200 OK      //客户端请求成功</li>
<li>303：重定向，即从原url重定向到新的url。 例如php 的hear函数header（”localtion:/index.php”）</li>
<li>400 Bad Request  //客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </li>
<li>403 Forbidden  //服务器收到请求，但是拒绝提供服务，一般是服务器路径没有权限或者是其他权限相关问题</li>
<li>404 Not Found  //请求资源不存在，eg：输入了错误的URL</li>
<li>500 Internal Server Error //服务器发生不可预期的错误：一般来说，这个问题都会在服务器端的源代码出现错误时出现，比如出现死循环。</li>
<li>502 Bad Gateway//作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。比如LNMP ,php-fpm没有启动就会报502错误。</li>
<li>503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常，比如java 容器部署war的时候，就出现503</li>
<li>504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应，比如nginx和php-fpm， php设置sleep（200），就会收到504 Gateway Time-out。注意：某些代理服务器在DNS查询超时时会返回400或者500错误</li>
</ol>
<h2 id="消息报头"><a href="#消息报头" class="headerlink" title="消息报头"></a>消息报头</h2><p>http常见的响应头如下所示：</p>
<h3 id="Cache头域"><a href="#Cache头域" class="headerlink" title="Cache头域"></a>Cache头域</h3><h4 id="Date："><a href="#Date：" class="headerlink" title="Date："></a>Date：</h4><p>作用：生成消息的具体时间和日期，即当前的GMT时间。</p>
<p>例如：　Date: Sun, 17 Mar 2013 08:12:54 GMT</p>
<h4 id="Expires："><a href="#Expires：" class="headerlink" title="Expires："></a>Expires：</h4><p>作用: 浏览器会在指定过期时间内使用本地缓存，指明应该在什么时候认为文档已经过期，从而不再缓存它。</p>
<p>例如: Expires: Thu, 19 Nov 1981 08:52:00 GMT　　</p>
<h4 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h4><p>作用：</p>
<p>例如: Vary: Accept-Encoding</p>
<h3 id="Cookie-Login-头域-1"><a href="#Cookie-Login-头域-1" class="headerlink" title="Cookie/Login 头域"></a>Cookie/Login 头域</h3><h4 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h4><p>作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题</p>
<p>例如: P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR</p>
<p>Set-Cookie</p>
<p>作用： 非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie.</p>
<p>例如: Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/</p>
<h3 id="Entity实体头域："><a href="#Entity实体头域：" class="headerlink" title="Entity实体头域："></a>Entity实体头域：</h3><p>实体内容的属性，包括实体信息类型，长度，压缩方法，最后一次修改时间，数据有效性等</p>
<h4 id="ETag："><a href="#ETag：" class="headerlink" title="ETag："></a>ETag：</h4><p>作用:  和If-None-Match 配合使用。 （实例请看上节中If-None-Match的实例）</p>
<p>例如: ETag: “03f2b33c0bfcc1:0”</p>
<h4 id="Last-Modified："><a href="#Last-Modified：" class="headerlink" title="Last-Modified："></a>Last-Modified：</h4><p>作用： 用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例）</p>
<p>例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT</p>
<h4 id="Content-Type：-1"><a href="#Content-Type：-1" class="headerlink" title="Content-Type："></a>Content-Type：</h4><p>作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集,<br>例如:</p>
<p>   Content-Type: text/html; charset=utf-8</p>
<p>　　Content-Type:text/html;charset=GB2312</p>
<p>　　Content-Type: image/jpeg</p>
<h4 id="Content-Length："><a href="#Content-Length：" class="headerlink" title="Content-Length："></a>Content-Length：</h4><p>指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。</p>
<p>　　例如: Content-Length: 19847</p>
<h4 id="Content-Encoding："><a href="#Content-Encoding：" class="headerlink" title="Content-Encoding："></a>Content-Encoding：</h4><p>作用：文档的编码（Encode）方法。一般是压缩方式。</p>
<p>WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。利用gzip压缩文档能够显著地减少HTML文档的下载时间。</p>
<p>例如：Content-Encoding：gzip</p>
<h4 id="Content-Language："><a href="#Content-Language：" class="headerlink" title="Content-Language："></a>Content-Language：</h4><p>作用： WEB服务器告诉浏览器自己响应的对象的语言者</p>
<p>例如： Content-Language:da</p>
<h3 id="Miscellaneous-头域-1"><a href="#Miscellaneous-头域-1" class="headerlink" title="Miscellaneous 头域"></a>Miscellaneous 头域</h3><h4 id="Server："><a href="#Server：" class="headerlink" title="Server："></a>Server：</h4><p>作用：指明HTTP服务器的软件信息</p>
<p>例如:Apache/2.2.8 (Win32) PHP/5.2.5</p>
<h4 id="X-Powered-By："><a href="#X-Powered-By：" class="headerlink" title="X-Powered-By："></a>X-Powered-By：</h4><p>作用：表示网站是用什么技术开发的</p>
<p>例如： X-Powered-By: PHP/5.2.5</p>
<h3 id="Transport头域"><a href="#Transport头域" class="headerlink" title="Transport头域"></a>Transport头域</h3><h4 id="Connection：-1"><a href="#Connection：-1" class="headerlink" title="Connection："></a>Connection：</h4><p>例如：　Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p>例如：  Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p>
<h3 id="Location头域"><a href="#Location头域" class="headerlink" title="Location头域"></a>Location头域</h3><h4 id="Location："><a href="#Location：" class="headerlink" title="Location："></a>Location：</h4><p>作用： 用于重定向一个新的位置， 包含新的URL地址</p>
<p>实例请看304状态实例</p>
<font color="red">无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。<br><br>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。<br><br>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。<br><br>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</font>

<h2 id="响应正文"><a href="#响应正文" class="headerlink" title="响应正文"></a>响应正文</h2><p>响应正文就是服务器返回的资源的内容，响应头和正文之间也必须用空行分隔。如：</p>
<pre><code>&lt;html&gt;  
&lt;head&gt;  
&lt;title&gt;HTTP响应示例&lt;title&gt;  
&lt;/head&gt;  
&lt;body&gt;  
Hello HTTP!  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p><a href="http://www.cnblogs.com/zery/p/5164795.html" target="_blank" rel="external">HTTPS详解</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/28/nginx安装篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/28/nginx安装篇/" itemprop="url">
                  nginx rtmp 安装篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-28T16:55:00+08:00">
                2017-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。</p>
<h3 id="nginx-rtmp安装教程"><a href="#nginx-rtmp安装教程" class="headerlink" title="nginx rtmp安装教程"></a>nginx rtmp安装教程</h3><p>通过神器homebrew安装</p>
<ul>
<li>brew update 更新本地brew</li>
<li>brew install homebrew/nginx/nginx-full –with-rtmp-module<br>nginx-full代码nginx的完整版</li>
<li>查看安装后的信息brew info nginx-full</li>
</ul>
<h3 id="修改nginx的配置文件"><a href="#修改nginx的配置文件" class="headerlink" title="修改nginx的配置文件"></a>修改nginx的配置文件</h3><blockquote>
<p>通过以上nginx后的配置文件路径在/usr/local/etc/nginx下<br>修改配置文件为以下（去掉了注释部分）<br></p>
</blockquote>
<pre><code>    #user  nobody;
    worker_processes  1;

    error_log  logs/error.log debug;

    events {
        worker_connections  1024;
    }

    http {
        include       mime.types;
        default_type  application/octet-stream;

        sendfile        on;
        keepalive_timeout  65;

        server {
            listen       8080;
            server_name  localhost;

            # rtmp stat
            location /stat {
                rtmp_stat all;
                rtmp_stat_stylesheet stat.xsl;
            }
            location /stat.xsl {
                # 这个路径一定要改
                root /usr/local/Cellar/rtmp-nginx-module/1.1.7.9/share/rtmp-nginx-module;
            }

            # rtmp control
            location /control {
                rtmp_control all;
            }

            error_page   500 502 503 504  /50x.html;
            location = /50x.html {
                root   html;
            }
        }
}

rtmp {
    server {
        listen 1935;
        ping 30s;
        notify_method get;

        application myapp {
            live on;
        }
    }
}
</code></pre><p> 编辑之后通过sudo nginx -s reload重启nginx。<br> 启动方式，进入ngix的目录，如我安装的目录：/usr/local/Cellar/nginx-full/1.10.3/bin 启动 sudo ./nginx</p>
<h2 id="ffmpeg安装"><a href="#ffmpeg安装" class="headerlink" title="ffmpeg安装"></a>ffmpeg安装</h2><h3 id="ffmpeg安装教程"><a href="#ffmpeg安装教程" class="headerlink" title="ffmpeg安装教程"></a>ffmpeg安装教程</h3><ol>
<li>brew unlink ffmpeg</li>
<li><p>brew install ffmpeg –with-ffplay</p>
</li>
<li><p>访问 <a href="http://localhost:8080/stat，如果正常打开，表示你已经成功了一大半" target="_blank" rel="external">http://localhost:8080/stat，如果正常打开，表示你已经成功了一大半</a></p>
</li>
<li>cd /System/Library/Compositions/</li>
<li>ffmpeg -re -i Yosemite.mov -c copy -f flv rtmp://localhost/myapp/mystream</li>
<li>ffplay rtmp://localhost/myapp/mystream<br>开始可能会出现如下的连接错误<br>Connection to tcp://localhost:1935 failed (Connection refused), trying next address</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/24/RTMP原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/24/RTMP原理/" itemprop="url">
                  直播日记-4 RTMP原理篇章
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-24T11:13:11+08:00">
                2017-03-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h2><p>RTMP协议是Real Time Message Protocol(实时信息传输协议)的缩写，它是由Adobe公司提出的一种应用层的协议，用来解决多媒体数据传输流的多路复用（Multiplexing）和分包（packetizing）的问题。</p>
<h3 id="1-总体介绍"><a href="#1-总体介绍" class="headerlink" title="1.总体介绍"></a>1.总体介绍</h3><p>RTMP协议是应用层协议，是要靠底层可靠的传输层协议（通常是TCP）来保证信息传输的可靠性的。在基于传输层协议的链接建立完成后，RTMP协议也要客户端和服务器通过“握手”来建立基于传输层链接之上的RTMP Connection链接，在Connection链接上会传输一些控制信息，如SetChunkSize,SetACKWindowSize。<br><br>其中CreateStream命令会创建一个Stream链接，用于传输具体的音视频数据和控制这些信息传输的命令信息。RTMP协议传输时会对数据做自己的格式化，这种格式的消息我们称之为RTMP Message，而实际传输的时候为了更好地实现多路复用、分包和信息的公平性，发送端会把Message划分为带有Message ID的Chunk，每个Chunk可能是一个单独的Message，也可能是Message的一部分，在接受端会根据chunk中包含的data的长度，message id和message的长度把chunk还原成完整的Message，从而实现信息的收发。</p>
<h3 id="2-握手"><a href="#2-握手" class="headerlink" title="2.握手"></a>2.握手</h3><p>要建立一个有效的RTMP Connection链接，首先要“握手”:客户端要向服务器发送C0,C1,C2（按序）三个chunk，服务器向客户端发送S0,S1,S2（按序）三个chunk，然后才能进行有效的信息传输。RTMP协议本身并没有规定这6个Message的具体传输顺序，但RTMP协议的实现者需要保证这几点：<br></p>
<ul>
<li>客户端要等收到S1之后才能发送C2<br></li>
<li>客户端要等收到S2之后才能发送其他信息（控制信息和真实音视频等数据)<br></li>
<li>服务端要等到收到C0之后发送S1<br></li>
<li>服务端必须等到收到C1之后才能发送S2<br></li>
<li>服务端必须等到收到C2之后才能发送其他信息（控制信息和真实音视频等数据）<br><br>服务端收发的顺序如下：<br><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/RTMP-HandShake.png?raw=true" alt="Alt text"><br><br>理论上来讲只要满足以上条件，如何安排6个Message的顺序都是可以的，但实际实现中为了在保证握手的身份验证功能的基础上尽量减少通信的次数，一般的发送顺序是这样的，这一点可以通过wireshark抓ffmpeg推流包进行验证：<br><br>｜client｜Server ｜<br><br>｜－－－C0+C1—-&gt;|<br><br>｜&lt;－－S0+S1+S2– |<br><br>｜－－－C2-－－－&gt; ｜<br></li>
</ul>
<blockquote>
<p>握手的包格式<br></p>
<ol>
<li>C0与S0的格式：<br><br><font color="red">c0和s0包是一个1字节,可以看作是一个byte<br></font><br>目前rtmp版本定义为3,0-2是早期的专利产品所使用的值,现已经废弃,4-31是预留值,32-255是禁用值(这样做是为了区分基于文本的协议,因为这些协议通常都是以一个可打印的字符开始),如果服务端不能识别客户请求的版本,那么它应该发送3的响应,客户端这时可以选择下降到版本3,也可以放弃这次握手<br></li>
<li>c1与s1格式<br><br>c1与s1长度为1536个字节,它们由以下字段组成:<br><br>a. 时间戳:该字段占4字节,包含了一个时间戳,它是所有从这个端点发送出去的将来数据块的起始点,它可以是零,或是任意值,为了同步多个数据块流,端点可能会将这个字段设成其它数据块流时间戳的当前值.<br><br>0:此标记位占4字节,并且必须是0<br><br>b. 随机数:该字段占1528字节,可以是任意值,因为每个端点必须区分已经初始化的握手和对等端点初始化的握手的响应,所以这个数据要足够的随机,当然这个也不需要密码级的随机或是动态值.<br></li>
<li>c2与s2格式<br><br>c2和s2包长都是1536字节,几乎是s1和c1的回显.<br><br>4.time1<br><br>该字段占4字节,包含有对方发送过来s1或c1的时间戳<br><br>time2<br><br>该字段占4字节,包含有对方发送过来的前一个包(s1或者c1)的时间戳<br><br>随机数回显<br><br>该字段占1528字节,包含有对方发送过来的随机数据字段,每个通信端点可以使用time1和time2字段,以及当前的时间戳,来快速估计带宽和/或连接延时,但这个数值基本上没法用.<br></li>
</ol>
</blockquote>
<h3 id="3-RTMP-Chunk-Stream"><a href="#3-RTMP-Chunk-Stream" class="headerlink" title="3. RTMP Chunk Stream"></a>3. RTMP Chunk Stream</h3><p>Chunk Stream是对传输RTMP Chunk的流的逻辑上的抽象，客户端和服务器之间有关RTMP的信息都在这个流上通信。这个流上的操作也是我们关注RTMP协议的重点。</p>
<h4 id="3-1-Message-消息"><a href="#3-1-Message-消息" class="headerlink" title="3.1 Message(消息)"></a>3.1 Message(消息)</h4><p>这里的Message是指满足该协议格式的、可以切分成Chunk发送的消息，消息包含的字段如下：<br></p>
<ul>
<li>Timestamp（时间戳）：消息的时间戳，4个字节<br></li>
<li>Length(长度)：是指Message Payload（消息负载）即音视频等信息的数据的长度，3个字节<br></li>
<li>TypeId(类型Id)：消息的类型Id，1个字节<br></li>
<li>Message Stream ID（消息的流ID）：每个消息的唯一标识，划分成Chunk和还原Chunk为Message的时候都是根据这个ID来辨识是否是同一个消息的Chunk的，4个字节，并且以小端格式存储</li>
</ul>
<h4 id="3-2-Chunking-Message分块"><a href="#3-2-Chunking-Message分块" class="headerlink" title="3.2 Chunking(Message分块)"></a>3.2 Chunking(Message分块)</h4><p>RTMP在收发数据的时候并不是以Message为单位的，而是把Message拆分成Chunk发送，而且必须在一个Chunk发送完成之后才能开始发送下一个Chunk。每个Chunk中带有MessageID代表属于哪个Message，接受端也会按照这个id来将chunk组装成Message。<br><br>通过拆分，数据量较大的Message可以被拆分成较小的“Message”，这样就可以避免优先级低的消息持续发送阻塞优先级高的数据，比如在视频的传输过程中，会包括视频帧，音频帧和RTMP控制信息，如果持续发送音频数据或者控制数据的话可能就会造成视频帧的阻塞，然后就会造成看视频时最烦人的卡顿现象。同时对于数据量较小的Message，可以通过对Chunk Header的字段来压缩信息，从而减少信息的传输量。（具体的压缩方式会在后面介绍）<br><br>Chunk的默认大小是128字节，在传输过程中，通过一个叫做Set Chunk Size的控制信息可以设置Chunk数据量的最大值，在发送端和接受端会各自维护一个Chunk Size，可以分别设置这个值来改变自己这一方发送的Chunk的最大大小。大一点的Chunk减少了计算每个chunk的时间从而减少了CPU的占用率，但是它会占用更多的时间在发送上，尤其是在低带宽的网络情况下，很可能会阻塞后面更重要信息的传输。小一点的Chunk可以减少这种阻塞问题，但小的Chunk会引入过多额外的信息（Chunk中的Header），少量多次的传输也可能会造成发送的间断导致不能充分利用高带宽的优势，因此并不适合在高比特率的流中传输。在实际发送时应对要发送的数据用不同的Chunk Size去尝试，通过抓包分析等手段得出合适的Chunk大小，并且在传输过程中可以根据当前的带宽信息和实际信息的大小动态调整Chunk的大小，从而尽量提高CPU的利用率并减少信息的阻塞机率。</p>
<h4 id="3-3Chunk-Format-块格式"><a href="#3-3Chunk-Format-块格式" class="headerlink" title="3.3Chunk Format(块格式)"></a>3.3Chunk Format(块格式)</h4><p><img src="https://github.com/jackytianhappy/ImgSource/blob/master/QQ20160228-0@2x.png?raw=true" alt="Alta text"></p>
<h5 id="3-3-1-Basic-Header-基本的头信息"><a href="#3-3-1-Basic-Header-基本的头信息" class="headerlink" title="3.3.1 Basic Header(基本的头信息):"></a>3.3.1 Basic Header(基本的头信息):</h5><p>包含了chunk stream ID（流通道Id）和chunk type（chunk的类型），chunk stream id一般被简写为CSID，用来唯一标识一个特定的流通道，chunk type决定了后面Message Header的格式。Basic Header的长度可能是1，2，或3个字节，其中chunk type的长度是固定的（占2位，注意单位是位，bit），Basic Header的长度取决于CSID的大小,在足够存储这两个字段的前提下最好用尽量少的字节从而减少由于引入Header增加的数据量。<br><br>RTMP协议支持用户自定义［3，65599］之间的CSID，0，1，2由协议保留表示特殊信息。0代表Basic Header总共要占用2个字节，CSID在［64，319］之间，1代表占用3个字节，CSID在［64，65599］之间，2代表该chunk是控制信息和一些命令信息，后面会有详细的介绍。<br><br>chunk type的长度固定为2位，因此CSID的长度是（6=8-2）、（14=16-2）、（22=24-2）中的一个。<br>当Basic Header为1个字节时，CSID占6位，6位最多可以表示64个数，因此这种情况下CSID在［0，63］之间，其中用户可自定义的范围为［3，63］。<br><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/chunk-basicheader1.png?raw=true" alt="Alta text"><br><br></p>
<p><font color="red">当Basic Header为2个字节时</font>，CSID占14位，此时协议将与chunk type所在字节的其他位都置为0，剩下的一个字节来表示CSID－64，这样共有8个字节来存储CSID，8位可以表示［0，255］共256个数，因此这种情况下CSID在［64，319］，其中319=255+64。<br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/chunk-basicheader2.png?raw=true" alt="Alta text"></p>
<p><font color="red">当Basic Header为3个字节时</font>，CSID占22位，此时协议将［2，8］字节置为1，余下的16个字节表示CSID－64，这样共有16个位来存储CSID，16位可以表示［0，65535］共65536个数，因此这种情况下CSID在［64，65599］，其中65599=65535+64，<b>Basic Header是采用小端存储的方式，越往后的字节数量级越高，因此通过这3个字节每一位的值来计算CSID时，应该是:&lt;第三个字节的值&gt;x256+&lt;第二个字节的值&gt;+64</b><br><br>可以看到2个字节和3个字节的Basic Header所能表示的CSID是有交集的［64，319］，但实际实现时还是应该秉着最少字节的原则使用2个字节的表示方式来表示［64，319］的CSID。</p>
<h5 id="3-3-2-Message-Header（消息的头信息）："><a href="#3-3-2-Message-Header（消息的头信息）：" class="headerlink" title="3.3.2 Message Header（消息的头信息）："></a>3.3.2 Message Header（消息的头信息）：</h5><p>包含了要发送的实际信息（可能是完整的，也可能是一部分）的描述信息。Message Header的格式和长度取决于Basic Header的chunk type，共有4种不同的格式，由上面所提到的Basic Header中的fmt字段控制。其中第一种格式可以表示其他三种表示的所有数据，但由于其他三种格式是基于对之前chunk的差量化的表示，因此可以更简洁地表示相同的数据，实际使用的时候还是应该采用尽量少的字节表示相同意义的数据。以下按照字节数从多到少的顺序分别介绍这4种格式的Message Header。<br></p>
<p><font color="red"><b>Type＝0:</b></font><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/chunk-messageheader0.png?raw=true" alt="Alta Text"><br>type=0时Message Header占用11个字节，其他三种能表示的数据它都能表示，但在chunk stream的开始的第一个chunk和头信息中的时间戳后退（即值与上一个chunk相比减小，通常在回退播放的时候会出现这种情况）的时候必须采用这种格式。<br></p>
<ol>
<li>timestamp（时间戳）：占用3个字节，因此它最多能表示到16777215=0xFFFFFF=2<br>24-1, 当它的值超过这个最大值时，这三个字节都置为1，这样实际的timestamp会转存到Extended Timestamp字段中，接受端在判断timestamp字段24个位都为1时就会去Extended timestamp中解析实际的时间戳.<br></li>
<li>message length（消息数据的长度）：占用3个字节，表示实际发送的消息的数据如音频帧、视频帧等数据的长度，单位是字节。注意这里是Message的长度，也就是chunk属于的Message的总数据长度，而不是chunk本身Data的数据的长度。<br></li>
<li>message type id(消息的类型id)：占用1个字节，表示实际发送的数据的类型，如8代表音频数据、9代表视频数据。<br></li>
<li>msg stream id（消息的流id）：占用4个字节，表示该chunk所在的流的ID，和Basic Header的CSID一样，它采用小端存储的方式<br><br><font color="red"><b>Type＝1:</b></font><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/chunk-messageheader1.png?raw=true" alt="Alta Text"><br>type=1时Message Header占用7个字节，<font color="red">省去了表示msg stream id的4个字节，表示此chunk和上一次发的chunk所在的流相同</font>，如果在发送端只和对端有一个流链接的时候可以尽量去采取这种格式。<br><br>timestamp delta：占用3个字节，注意这里和type＝0时不同，存储的是和上一个chunk的时间差。类似上面提到的timestamp，当它的值超过3个字节所能表示的最大值时，三个字节都置为1，实际的时间戳差值就会转存到Extended Timestamp字段中，接受端在判断timestamp delta字段24个位都为1时就会去Extended timestamp中解析时机的与上次时间戳的差值。<br><br><font color="red"><b>Type＝2:</b></font><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/chunk-messageheader2.png?raw=true" alt="Alta Text"><br>type=2时Message Header占用3个字节，相对于type＝1格式又省去了表示消息长度的3个字节和表示消息类型的1个字节，表示此chunk和上一次发送的chunk所在的流、消息的长度和消息的类型都相同。余下的这三个字节表示timestamp delta，使用同type＝1<br><br><font color="red"><b>Type＝3:</b></font><br><br>0字节！！！好吧，它表示这个chunk的Message Header和上一个是完全相同的，自然就不用再传输一遍了。当它跟在Type＝0的chunk后面时，表示和前一个chunk的时间戳都是相同的。什么时候连时间戳都相同呢？就是一个Message拆分成了多个chunk，这个chunk和上一个chunk同属于一个Message。而当它跟在Type＝1或者Type＝2的chunk后面时，表示和前一个chunk的时间戳的差是相同的。比如第一个chunk的Type＝0，timestamp＝100，第二个chunk的Type＝2，timestamp delta＝20，表示时间戳为100+20=120，第三个chunk的Type＝3，表示timestamp delta＝20，时间戳为120+20=140<h5 id="3-3-3-Extended-Timestamp（扩展时间戳）："><a href="#3-3-3-Extended-Timestamp（扩展时间戳）：" class="headerlink" title="3.3.3 Extended Timestamp（扩展时间戳）："></a>3.3.3 Extended Timestamp（扩展时间戳）：</h5>上面我们提到在chunk中会有时间戳timestamp和时间戳差timestamp delta，并且它们不会同时存在，只有这两者之一大于3个字节能表示的最大数值0xFFFFFF＝16777215时，才会用这个字段来表示真正的时间戳，否则这个字段为0。扩展时间戳占4个字节，能表示的最大数值就是0xFFFFFFFF＝4294967295。当扩展时间戳启用时，timestamp字段或者timestamp delta要全置为1，表示应该去扩展时间戳字段来提取真正的时间戳或者时间戳差。注意扩展时间戳存储的是完整值，而不是减去时间戳或者时间戳差的值。<h6 id="3-3-4-Chunk-Data（块数据）："><a href="#3-3-4-Chunk-Data（块数据）：" class="headerlink" title="3.3.4 Chunk Data（块数据）："></a>3.3.4 Chunk Data（块数据）：</h6>用户层面上真正想要发送的与协议无关的数据，长度在(0,chunkSize]之间。<h5 id="3-3-5-chunk表示例1"><a href="#3-3-5-chunk表示例1" class="headerlink" title="3.3.5 chunk表示例1"></a>3.3.5 chunk表示例1</h5><img src="https://github.com/jackytianhappy/ImgSource/blob/master/sample-chunk1.png?raw=true" alt="Alta Text"><br>首先包含第一个Message的chunk的Chunk Type为0，因为它没有前面可参考的chunk，timestamp为1000，表示时间戳。type为0的header占用11个字节，假定chunkstreamId为3<127，因此basic header占用1个字节，再加上data的32个字节，因此第一个chunk共44＝11+1+32个字节。<br=""><br>第二个chunk和第一个chunk的CSID，TypeId，Data的长度都相同，因此采用Chunk Type＝2，timestamp delta＝1020-1000＝20，因此第二个chunk占用36=3+1+32个字节。<br><br>第三个chunk和第二个chunk的CSID，TypeId，Data的长度和时间戳差都相同，因此采用Chunk Type＝3省去全部Message Header的信息，占用33=1+32个字节。<br><br>第四个chunk和第三个chunk情况相同，也占用33=1+32个字节。<br><br>最后实际发送的chunk如下：<br><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/sample-chunk1-result.png?raw=true" alt="Alta Text"></127，因此basic></li>
</ol>
<h5 id="3-3-6-chunk表示例2"><a href="#3-3-6-chunk表示例2" class="headerlink" title="3.3.6 chunk表示例2"></a>3.3.6 chunk表示例2</h5><p><img src="https://github.com/jackytianhappy/ImgSource/blob/master/sample-chunk2.png?raw=true" alt="Alta Text"><br>注意到Data的Length＝307&gt;128,因此这个Message要切分成几个chunk发送，第一个chunk的Type＝0，Timestamp＝1000，承担128个字节的Data，因此共占用140=11+1+128个字节<br><br>第二个chunk也要发送128个字节，其他字段也同第一个chunk，因此采用Chunk Type＝3，此时时间戳也为1000，共占用129=1+128个字节。<br><br>第三个chunk要发送的Data的长度为307-128-128=51个字节，还是采用Type＝3，共占用1+51＝52个字节。<br><br>最后实际发送的chunk如下：<br><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/sample-chunk2-result.png?raw=true" alt="Alta Text"></p>
<h4 id="3-4-协议控制消息（Protocol-Control-Message）"><a href="#3-4-协议控制消息（Protocol-Control-Message）" class="headerlink" title="3.4 协议控制消息（Protocol Control Message）"></a>3.4 协议控制消息（Protocol Control Message）</h4><p>在RTMP的chunk流会用一些特殊的值来代表协议的控制消息，<font color="red">它们的Message Stream ID必须为0（代表控制流信息）</font>,CSID必须为2，Message Type ID可以为1，2，3，5，6，具体代表的消息会在下面依次说明。控制消息的接受端会忽略掉chunk中的时间戳，收到后立即生效。<br></p>
<ul>
<li><font color="red"><b>Set Chunk Size(Message Type ID=1):</b></font> 设置chunk中Data字段所能承载的最大字节数，默认为128B，通信过程中可以通过发送该消息来设置chunk Size的大小（不得小于128B），而且通信双方会各自维护一个chunkSize，两端的chunkSize是独立的。比如当A想向B发送一个200B的Message，但默认的chunkSize是128B，因此就要将该消息拆分为Data分别为128B和72B的两个chunk发送，如果此时先发送一个设置chunkSize为256B的消息，再发送Data为200B的chunk，本地不再划分Message，B接受到Set Chunk Size的协议控制消息时会调整的接受的chunk的Data的大小，也不用再将两个chunk组成为一个Message。<br>以下为代表Set Chunk Size消息的chunk的Data：<img src="https://github.com/jackytianhappy/ImgSource/blob/master/set-chunksize.png?raw=true" alt="Atla Text">其中第一位必须为0，chunk Size占31个位，最大可代表2147483647＝0x7FFFFFFF＝231-1，但实际上所有大于16777215=0xFFFFFF的值都用不上，因为chunk size不能大于Message的长度，表示Message的长度字段是用3个字节表示的，最大只能为0xFFFFFF。<br></li>
<li><font color="red"><b>Set Chunk Size(Message Type ID=2):</b></font>当一个Message被切分为多个chunk，接受端只接收到了部分chunk时，发送该控制消息表示发送端不再传输同Message的chunk，接受端接收到这个消息后要丢弃这些不完整的chunk。Data数据中只需要一个CSID，表示丢弃该CSID的所有已接收到的chunk。<img src="https://raw.githubusercontent.com/jackytianhappy/ImgSource/9abe6a176bc879cf1d1c6103d0cffa6b65642d33/abort%EF%BC%8Dmessage.png" alt="Alta Text"></li>
<li><font color="red"><b>Set Chunk Size(Message Type ID=3):</b></font>当收到对端的消息大小等于窗口大小（Window Size）时接受端要回馈一个ACK给发送端告知对方可以继续发送数据。窗口大小就是指收到接受端返回的ACK前最多可以发送的字节数量，返回的ACK中会带有从发送上一个ACK后接收到的字节数。<img src="https://raw.githubusercontent.com/jackytianhappy/ImgSource/ad24e24e795a3d6299e3d082846a043dd50cd150/ACK-message.png" alt="Alta Text"></li>
<li><font color="red"><b>Set Chunk Size(Message Type ID=5):</b></font>发送端在接收到接受端返回的两个ACK间最多可以发送的字节数。<img src="https://raw.githubusercontent.com/jackytianhappy/ImgSource/28d71a4d34b313d0c318640aa512ce8b0615fb25/ACK-windowsize.png" alt="Alta Text">1.Hard(Limit Type＝0):接受端应该将Window Ack Size设置为消息中的值<br>2.Soft(Limit Type=1):接受端可以讲Window Ack Size设为消息中的值，也可以保存原来的值（前提是原来的Size小与该控制消息中的Window Ack Size）<br>3.Dynamic(Limit Type=2):如果上次的Set Peer Bandwidth消息中的Limit Type为0，本次也按Hard处理，否则忽略本消息，不去设置Window Ack Size。</li>
</ul>
<h3 id="4-不同类型的RTMP-Message"><a href="#4-不同类型的RTMP-Message" class="headerlink" title="4 不同类型的RTMP Message"></a>4 不同类型的RTMP Message</h3><ul>
<li>Command Message(命令消息，Message Type ID＝17或20)：表示在客户端盒服务器间传递的在对端执行某些操作的命令消息，如connect表示连接对端，对端如果同意连接的话会记录发送端信息并返回连接成功消息，publish表示开始向对方推流，接受端接到命令后准备好接受对端发送的流信息，后面会对比较常见的Command Message具体介绍。当信息使用AMF0编码时，Message Type ID＝20，AMF3编码时Message Type ID＝17.</li>
<li>Data Message（数据消息，Message Type ID＝15或18）：传递一些元数据（MetaData，比如视频名，分辨率等等）或者用户自定义的一些消息。当信息使用AMF0编码时，Message Type ID＝18，AMF3编码时Message Type ID＝15.</li>
<li>Shared Object Message(共享消息，Message Type ID＝16或19)：表示一个Flash类型的对象，由键值对的集合组成，用于多客户端，多实例时使用。当信息使用AMF0编码时，Message Type ID＝19，AMF3编码时Message Type ID＝16.</li>
<li>Audio Message（音频信息，Message Type ID＝8）：音频数据。</li>
<li>Video Message（视频信息，Message Type ID＝9）：视频数据。</li>
<li>Aggregate Message (聚集信息，Message Type ID＝22)：多个RTMP子消息的集合</li>
<li>User Control Message Events(用户控制消息，Message Type ID=4):告知对方执行该信息中包含的用户控制事件，比如Stream Begin事件告知对方流信息开始传输。和前面提到的协议控制信息（Protocol Control Message）不同，这是在RTMP协议层的，而不是在RTMP chunk流协议层的，这个很容易弄混。该信息在chunk流中发送时，Message Stream ID=0,Chunk Stream Id=2,Message Type Id=4。<br>———下面对以上7种信息具体介绍———-　<br><h4 id="4-1-Command-Message-命令消息，Message-Type-ID＝17或20"><a href="#4-1-Command-Message-命令消息，Message-Type-ID＝17或20" class="headerlink" title="4.1 Command Message(命令消息，Message Type ID＝17或20)"></a>4.1 Command Message(命令消息，Message Type ID＝17或20)</h4>发送端发送时会带有命令的名字，如connect，TransactionID表示此次命令的标识，Command Object表示相关参数。接受端收到命令后，会返回以下三种消息中的一种：_result 消息表示接受该命令，对端可以继续往下执行流程，_error消息代表拒绝该命令要执行的操作，method name消息代表要在之前命令的发送端执行的函数名称。这三种回应的消息都要带有收到的命令消息中的TransactionId来表示本次的回应作用于哪个命令。<br><br>可以认为发送命令消息的对象有两种，一种是NetConnection，表示双端的上层连接，一种是NetStream，表示流信息的传输通道，控制流信息的状态，如Play播放流，Pause暂停。</li>
</ul>
<h4 id="4-1-1-NetConnection-Commands-连接层的命令"><a href="#4-1-1-NetConnection-Commands-连接层的命令" class="headerlink" title="4.1.1 NetConnection Commands(连接层的命令)"></a>4.1.1 NetConnection Commands(连接层的命令)</h4><p>用来管理双端之间的连接状态，同时也提供了异步远程方法调用（RPC）在对端执行某方法，以下是常见的连接层的命令：</p>
<h5 id="4-1-1-1-connect-用于客户端向服务器发送连接请求，消息的结构如下："><a href="#4-1-1-1-connect-用于客户端向服务器发送连接请求，消息的结构如下：" class="headerlink" title="4.1.1.1 connect:用于客户端向服务器发送连接请求，消息的结构如下："></a>4.1.1.1 connect:用于客户端向服务器发送连接请求，消息的结构如下：</h5><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>命令的名字，如”connect”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>恒为1</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Object</td>
<td>键值对集合表示的命令参数</td>
</tr>
<tr>
<td>Optional User Arguments（额外的用户参数)</td>
<td>Object</td>
<td>用户自定义的额外信息</td>
</tr>
</tbody>
</table>
<p>第三个字段中的Command Object中会涉及到很多键值对，这里不再一一列出，使用时可以参考协议的官方文档。<br>消息的回应有两种，_result表示接受连接，_error表示连接失败</p>
<h5 id="4-1-1-2-Call-用于在对端执行某函数，即常说的RPC：远程进程调用，消息的结构如下："><a href="#4-1-1-2-Call-用于在对端执行某函数，即常说的RPC：远程进程调用，消息的结构如下：" class="headerlink" title="4.1.1.2 Call:用于在对端执行某函数，即常说的RPC：远程进程调用，消息的结构如下："></a>4.1.1.2 Call:用于在对端执行某函数，即常说的RPC：远程进程调用，消息的结构如下：</h5><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Procedure Name(进程名)</td>
<td>String</td>
<td>要调用的进程名称</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>上面接收到命令消息汇总的Transaction ID</td>
</tr>
<tr>
<td>Command Object</td>
<td>Object</td>
<td>命令参数</td>
</tr>
<tr>
<td>Optional Arguents</td>
<td>Object</td>
<td>用户自定</td>
<td>义参数</td>
</tr>
</tbody>
</table>
<p>如果消息中的TransactionID不为0的话，对端需要对该命令做出响应，响应的消息结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name(命令名)</td>
<td>String</td>
<td>命令的名称</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>上面接收到的命令消息中的TransactionID</td>
</tr>
<tr>
<td>Command Object</td>
<td>Object</td>
<td>命令参数</td>
</tr>
<tr>
<td>Optional Arguments</td>
<td>Object</td>
<td>用户自定义参数</td>
</tr>
</tbody>
</table>
<h6 id="4-1-1-3-Create-Stream：创建传递具体信息的通道，从而可以在这个流中传递具体信息，传输信息单元为Chunk。"><a href="#4-1-1-3-Create-Stream：创建传递具体信息的通道，从而可以在这个流中传递具体信息，传输信息单元为Chunk。" class="headerlink" title="4.1.1.3 Create Stream：创建传递具体信息的通道，从而可以在这个流中传递具体信息，传输信息单元为Chunk。"></a>4.1.1.3 Create Stream：创建传递具体信息的通道，从而可以在这个流中传递具体信息，传输信息单元为Chunk。</h6><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name(命令名)</td>
<td>String</td>
<td>“createStream”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>上面接收到的命令消息中的TransactionID</td>
</tr>
<tr>
<td>Command Object</td>
<td>Object</td>
<td>命令参数</td>
</tr>
<tr>
<td>Optional Arguments</td>
<td>Object</td>
<td>用户自定义参数</td>
</tr>
</tbody>
</table>
<h4 id="4-1-2-NetStream-Commands-流连接上的命令"><a href="#4-1-2-NetStream-Commands-流连接上的命令" class="headerlink" title="4.1.2 NetStream Commands(流连接上的命令)"></a>4.1.2 NetStream Commands(流连接上的命令)</h4><p>Netstream建立在NetConnection之上，通过NetConnection的createStream命令创建，用于传输具体的音频、视频等信息。在传输层协议之上只能连接一个NetConnection，但一个NetConnection可以建立多个NetStream来建立不同的流通道传输数据。<br><br>以下会列出一些常用的NetStream Commands，服务端收到命令后会通过onStatus的命令来响应客户端，表示当前NetStream的状态。<br><br>onStatus命令的消息结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“onStatus”</td>
</tr>
<tr>
<td>TransactionID    Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL</td>
<td>对onSatus命令来说不需要这个字段</td>
</tr>
<tr>
<td>Info Object</td>
<td>Object</td>
<td>AMF类型的Object，至少包含以下三个属性：1，“level”，String类型，可以为“warning”、”status”、”error”中的一种；2，”code”,String类型，代表具体状态的关键字,比如”NetStream.Play.Start”表示开始播流；3，”description”，String类型，代表对当前状态的描述，提供对当前状态可读性更好的解释，除了这三种必要信息，用户还可以自己增加自定义的键值对</td>
</tr>
</tbody>
</table>
<h5 id="4-1-2-1-play-播放"><a href="#4-1-2-1-play-播放" class="headerlink" title="4.1.2.1 play(播放):"></a>4.1.2.1 play(播放):</h5><p>由客户端向服务器发起请求从服务器端接受数据（如果传输的信息是视频的话就是请求开始播流），可以多次调用，这样本地就会形成一组数据流的接收者。注意其中有一个reset字段，表示是覆盖之前的播流（设为true）还是重新开始一路播放（设为false）。<br><br>play命令的结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令名</td>
<td>String</td>
<td>“play”</td>
</tr>
<tr>
<td>事务ID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>命令参数对象</td>
<td>Null</td>
<td>不需要此字段，设为空</td>
</tr>
<tr>
<td>流名称</td>
<td>String</td>
<td>要播放的流的名称</td>
</tr>
<tr>
<td>开始位置</td>
<td>Number</td>
<td>可选参数，表示从何时开始播流，以秒为单位。默认为－2，代表选取对应该流名称的直播流，即当前正在推送的流开始播放，如果对应该名称的直播流不存在，就选取该名称的流的录播版本，如果这也没有，当前播流端要等待直到对端开始该名称的流的直播。如果传值－1，那么只会选取直播流进行播放，即使有录播流也不会播放；如果传值或者正数，就代表从该流的该时间点开始播放，如果流不存在的话就会自动播放播放列表中的下一个流</td>
</tr>
<tr>
<td>周期</td>
<td>Number</td>
<td>可选参数，表示回退的最小间隔单位，以秒为单位计数。默认值为－1，代表直到直播流不再可用或者录播流停止后才能回退播放；如果传值为0，代表从当前帧开始播放</td>
</tr>
<tr>
<td>重置</td>
<td>Boolean</td>
<td>可选参数，true代表清除之前的流，重新开始一路播放，false代表保留原来的流，向本地的播放列表中再添加一条播放流</td>
</tr>
</tbody>
</table>
<h5 id="4-1-2-2-play2（播放）："><a href="#4-1-2-2-play2（播放）：" class="headerlink" title="4.1.2.2 play2（播放）："></a>4.1.2.2 play2（播放）：</h5><p>和上面的play命令不同的是，play2命令可以将当前正在播放的流切换到同样数据但不同比特率的流上，服务器端会维护多种比特率的文件来供客户端使用play2命令来切换。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“play2”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL,对onSatus命令来说不需要这个字段</td>
<td></td>
</tr>
<tr>
<td>parameters</td>
<td>Object</td>
<td>AMF编码的Flash对象，包括了一些用于描述flash.net.NetstreamPlayOptions ActionScript obejct的参数</td>
</tr>
</tbody>
</table>
<h6 id="4-1-2-3-deleteStream-删除流-："><a href="#4-1-2-3-deleteStream-删除流-：" class="headerlink" title="4.1.2.3 deleteStream(删除流)："></a>4.1.2.3 deleteStream(删除流)：</h6><p>用于客户端告知服务器端本地的某个流对象已被删除，不需要再传输此路流。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“deleteStream”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL,对onSatus命令来说不需要这个字段</td>
<td></td>
</tr>
<tr>
<td>Stream ID（流ID)</td>
<td>Number</td>
<td>本地已删除，不再需要服务器传输的流的ID</td>
</tr>
</tbody>
</table>
<h5 id="4-1-2-4-receiveAudio-接收音频"><a href="#4-1-2-4-receiveAudio-接收音频" class="headerlink" title="4.1.2.4 receiveAudio(接收音频)"></a>4.1.2.4 receiveAudio(接收音频)</h5><p>通知服务器端该客户端是否要发送音频<br>receiveAudio命令结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“receiveAudio”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL</td>
<td>对onSatus命令来说不需要这个字段</td>
</tr>
<tr>
<td>Bool Flag</td>
<td>Boolean</td>
<td>true表示发送音频，如果该值为false，服务器端不做响应，如果为true的话，服务器端就会准备接受音频数据，会向客户端回复NetStream.Seek.Notify和NetStream.Play.Start的Onstatus命令告知客户端当前流的状态</td>
</tr>
</tbody>
</table>
<h6 id="4-1-2-5-receiveVideo-接收视频-："><a href="#4-1-2-5-receiveVideo-接收视频-：" class="headerlink" title="4.1.2.5 receiveVideo(接收视频)："></a>4.1.2.5 receiveVideo(接收视频)：</h6><p>通知服务器端该客户端是否要发送视频<br>receiveVideo命令结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“receiveVideo”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL</td>
<td>对onSatus命令来说不需要这个字段</td>
</tr>
<tr>
<td>Bool Flag</td>
<td>Boolean</td>
<td>true表示发送视频，如果该值为false，服务器端不做响应，如果为true的话，服务器端就会准备接受视频数据，会向客户端回复NetStream.Seek.Notify和NetStream.Play.Start的Onstatus命令告知客户端当前流的状态</td>
</tr>
</tbody>
</table>
<h5 id="4-1-2-6-publish-推送数据-："><a href="#4-1-2-6-publish-推送数据-：" class="headerlink" title="4.1.2.6 publish(推送数据)："></a>4.1.2.6 publish(推送数据)：</h5><p>由客户端向服务器发起请求推流到服务器。<br>publish命令结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“publish”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL,对onSatus命令来说不需要这个字段</td>
<td></td>
</tr>
<tr>
<td>Publishing Name（推流的名称）</td>
<td>String    流名称｜</td>
</tr>
<tr>
<td>Publishing Type（推流类型）</td>
<td>String</td>
<td>“live”、”record”、”append”中的一种。live表示该推流文件不会在服务器端存储；record表示该推流的文件会在服务器应用程序下的子目录下保存以便后续播放，如果文件已经存在的话删除原来所有的内容重新写入；append也会将推流数据保存在服务器端，如果文件不存在的话就会建立一个新文件写入，如果对应该流的文件已经存在的话保存原来的数据，在文件末尾接着写入</td>
</tr>
</tbody>
</table>
<h5 id="4-1-2-7-seek-定位流的位置-："><a href="#4-1-2-7-seek-定位流的位置-：" class="headerlink" title="4.1.2.7 seek(定位流的位置)："></a>4.1.2.7 seek(定位流的位置)：</h5><p>定位到视频或音频的某个位置，以毫秒为单位。<br>seek命令的结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“seek”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL,对onSatus命令来说不需要这个字段</td>
<td></td>
</tr>
<tr>
<td>milliSeconds</td>
<td>Number</td>
<td>定位到该文件的xx毫秒处｜</td>
</tr>
</tbody>
</table>
<h5 id="4-1-2-8-pause（暂停）："><a href="#4-1-2-8-pause（暂停）：" class="headerlink" title="4.1.2.8 pause（暂停）："></a>4.1.2.8 pause（暂停）：</h5><p>客户端告知服务端停止或恢复播放。<br>pause命令的结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“pause”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL,对onSatus命令来说不需要这个字段</td>
<td></td>
</tr>
<tr>
<td>Pause/Unpause Flag</td>
<td>Boolean</td>
<td>true表示暂停，false表示恢复</td>
</tr>
<tr>
<td>milliSeconds</td>
<td>Number</td>
<td>暂停或者恢复的时间，以毫秒为单位｜</td>
</tr>
</tbody>
</table>
<p>如果Pause为true即表示客户端请求暂停的话，服务端暂停对应的流会返回NetStream.Pause.Notify的onStatus命令来告知客户端当前流处于暂停的状态，当Pause为false时，服务端会返回NetStream.Unpause.Notify的命令来告知客户端当前流恢复。如果服务端对该命令响应失败，返回_error信息。</p>
<h3 id="5-代表流程"><a href="#5-代表流程" class="headerlink" title="5.代表流程"></a>5.代表流程</h3><h4 id="5-1推流流程"><a href="#5-1推流流程" class="headerlink" title="5.1推流流程"></a>5.1推流流程</h4><p><img src="https://github.com/jackytianhappy/ImgSource/blob/master/publish-flow.png?raw=true" alt="Alta Text"></p>
<h4 id="5-2-播放流程"><a href="#5-2-播放流程" class="headerlink" title="5.2 播放流程"></a>5.2 播放流程</h4><p><img src="https://github.com/jackytianhappy/ImgSource/blob/master/play-flow.png?raw=true" alt="Alta Text"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Jacky Tian" />
          <p class="site-author-name" itemprop="name">Jacky Tian</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jacky Tian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  






  





  

  

  

  

</body>
</html>
