<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Jakcy’s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jakcy’s Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jakcy’s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Jakcy’s Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jakcy’s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">第一个博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/12/Block内存地址/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/12/Block内存地址/" itemprop="url">
                  __Block内存地址
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T15:47:10+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>为什么添加__block的外部变量在闭包内部能够被修改？</p>
</blockquote>
<pre><code>int a = 0;          //栈区
void (^foo)(void) = ^{ 
   NSlog(@&quot;%@&quot;,a);   //堆区
};
foo(); 
//这里，a的值被修改为1
</code></pre><p>需要修改a的值</p>
<pre><code>__block int a = 0;
NSLog(@&quot;定义前：%p&quot;, &amp;a);         //栈区
void (^foo)(void) = ^{
    a = 1;
    NSLog(@&quot;block内部：%p&quot;, &amp;a);    //堆区
};
NSLog(@&quot;定义后：%p&quot;, &amp;a);         //堆区
foo();
</code></pre><p>添加<strong>block之后，变量a会被拷贝到堆区，同时经过编译之后生成一个</strong>forwarding的指针，这个指针指向的变量原栈区，修改时，实际上是通过<strong>forwarding指针访问堆区的内容进行修改。这样实现了修改。不加</strong>block不允许修改的实际上是变量的在栈中的指针地址。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/12/iOS内存泄漏工具以及实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/12/iOS内存泄漏工具以及实现原理/" itemprop="url">
                  以及实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T14:25:31+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="检测原理或实现思路"><a href="#检测原理或实现思路" class="headerlink" title="检测原理或实现思路"></a>检测原理或实现思路</h1><blockquote>
<p>开源库 例如 HeapInspector-for-iOS 和 MSLeakHunter。</p>
</blockquote>
<p>HeapInspector-for-iOS 可以说是 Allocations 的改进。它通过 hook 掉 alloc，dealloc，retain，release 等方法，来记录对象的生命周期。具体的检测内存泄露的方法和原理，与 Instrument 的 Allocations 一致。然而它跟 Allocations 一样，存在的问题是，你需要一个个场景去重复的操作，还有检测不及时。</p>
<p>MSLeakHunter 就简单得多，它只检测 UIViewController 和 UIView，通过 hook 掉 UIViewController 的 -viewDidDisappear: 方法，并认为 -viewDidDisappear: 后，UIViewController 将很快被释放，如果 UIViewController 没有被释放，则打个建议日志。这种做法其实不是很好，-viewDidDisappear: 被调用可能是因为又 push 进来一个新的 ViewController，把当前的 ViewController 挡住了，所以可能有很多错误的建议，需要结合你实际的操作去具体地分析日志。</p>
<p>#MLeaksFinder原理<br>MLeaksFinder 一开始从 UIViewController 入手。我们知道，当一个 UIViewController 被 pop 或 dismiss 后，该 UIViewController 包括它的 view，view 的 subviews 等等将很快被释放（除非你把它设计成单例，或者持有它的强引用，但一般很少这样做）。于是，我们只需在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 UIViewController，它的 view，view 的 subviews 等等是否还存在。</p>
<p>具体的方法是，为基类 NSObject 添加一个方法 -willDealloc 方法，该方法的作用是，先用一个弱指针指向 self，并在一小段时间(3秒)后，通过这个弱指针调用 -assertNotDealloc，而 -assertNotDealloc 主要作用是直接中断言。</p>
<pre><code>- (BOOL)willDealloc {
    __weak id weakSelf = self;
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        [weakSelf assertNotDealloc];
    });
    return YES;
}
- (void)assertNotDealloc {
     NSAssert(NO, @“”);
}
</code></pre><p>这样，当我们认为某个对象应该要被释放了，在释放前调用这个方法，如果3秒后它被释放成功，weakSelf 就指向 nil，不会调用到 -assertNotDealloc 方法，也就不会中断言，如果它没被释放（泄露了），-assertNotDealloc 就会被调用中断言。这样，当一个 UIViewController 被 pop 或 dismiss 时（我们认为它应该要被释放了），我们遍历该 UIViewController 上的所有 view，依次调 -willDealloc，若3秒后没被释放，就会中断言。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/06/Runloop详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/06/Runloop详解/" itemprop="url">
                  Runloop详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-06T14:22:17+08:00">
                2017-04-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Runloop实现了自动释放，延迟回调，触摸事件，屏幕刷新等功能。</p>
</blockquote>
<h2 id="Runloop概念"><a href="#Runloop概念" class="headerlink" title="Runloop概念"></a>Runloop概念</h2><ol>
<li><p>NSRunLoop是iOS消息机制的处理模式:<br><br>NSRunLoop的主要作用：控制NSRunLoop里面线程的执行和休眠，在有事情做的时候使当前NSRunLoop控制的线程工作，没有事情做让当前NSRunLoop的控制的线程休眠。</p>
</li>
<li><p>NSRunLoop 就是一直在循环检测，从线程start到线程end，检测inputsource(如点击，双击等操作)同步事件，检测timesource同步事件，检测到输入源会执行处理函数，首先会产生通知，corefunction向线程添加runloop observers来监听事件，意在监听事件发生时来做处理。</p>
</li>
<li><p>runloopmode是一个集合，包括监听：事件源，定时器，以及需通知的runloop observers,模式包括：<br></p>
<p> default模式：几乎包括所有输入源(除NSConnection) NSDefaultRunLoopMode模式</p>
<p> Modal模式：处理modal panels事件,需要等待处理的input source为modal panel时设置，比如NSSavePanel和NSOpenPanel。</p>
<p> connection模式：处理NSConnection事件，属于系统内部，用户基本不用</p>
<p> event tracking模式：使用该模式来处理用户界面相关的事件,例如在拖动loop或其他user interface tracking loops时处于此种模式下，在此模式下会限制输入事件的处理。例如，当手指按住UITableView拖动时就会处于此模式</p>
<p> common modes模式：这是一个伪模式，其为一组run loop mode的集合，将输入源加入此模式意味着在Common Modes中包含的所有模式下都可以处理。在Cocoa应用程序中，默认情况下Common Modes包含default modes,modal modes,event Tracking modes, 可使用CFRunLoopAddCommonMode方法向Common Modes中添加自定义modes。</p>
</li>
</ol>
<p>注意这个并不是一个特定的mode，而是一个mode的集合，而runloop必须运行在一个特定的mode下。</p>
<ol>
<li>每次运行一个run loop，你指定（显式或隐式）run loop的运行模式。当相应的模式传递给run loop时，只有与该模式对应的 input sources才被监控并允许run loop对事件进行处理（与此类似，也只有与该模式对应的observers才会被通知）</li>
<li>子线程中的NSRunLoop需要手动启动，在子线程中使用timer要启动NSRunLoop。</li>
</ol>
<p><a href="http://blog.wangruofeng007.com/blog/2016/01/12/runloopxiang-jie/" target="_blank" rel="external">这里有篇不错的文章</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/05/iOS中图片的解压缩详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/05/iOS中图片的解压缩详解/" itemprop="url">
                  性能优化-iOS中图片的解压缩
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-05T16:20:54+08:00">
                2017-04-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="图片加载的工作流"><a href="#图片加载的工作流" class="headerlink" title="图片加载的工作流"></a>图片加载的工作流</h2><ol>
<li>假设我们使用 +imageWithContentsOfFile: 方法从磁盘中加载一张图片，这个时候的图片并没有解压缩；</li>
<li>然后将生成的 UIImage 赋值给 UIImageView ；</li>
<li>接着一个隐式的 CATransaction 捕获到了 UIImageView 图层树的变化；</li>
<li>在主线程的下一个 run loop 到来时，Core Animation 提交了这个隐式的 transaction ，这个过程可能会对图片进行 copy 操作，而受图片是否字节对齐等因素的影响，这个 copy 操作可能会涉及以下部分或全部步骤：<br><br> a. 分配内存缓冲区用于管理文件 IO 和解压缩操作<br><br> b. 将文件数据从磁盘读到内存中<br><br> c. 将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作<br><br> d. 最后 Core Animation 使用未压缩的位图数据渲染 UIImageView 的图层<br><br>图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。</li>
</ol>
<h2 id="为什么需要解压缩"><a href="#为什么需要解压缩" class="headerlink" title="为什么需要解压缩"></a>为什么需要解压缩</h2><p>图片的解压缩需要消耗大量的 CPU 时间，那么我们为什么还要对图片进行解压缩呢？是否可以不经过解压缩，而直接将图片显示到屏幕上呢？答案是否定的。要想弄明白这个问题，我们首先需要知道什么是位图：<br><br>位图：位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点。我们在应用中经常用到的 JPEG 和 PNG 图片就是位图。下面，我们来看一个具体的例子，这是一张 PNG 图片，像素为 30 × 30 ，文件大小为 843B ：<br><br>图片设置方式：</p>
<pre><code>UIImage *image = [UIImage imageNamed:@&quot;check_green&quot;];
CFDataRef rawData = CGDataProviderCopyData(CGImageGetDataProvider(image.CGImage));
</code></pre><p>获取到的图片原始数据为，大小为3600B</p>
<pre><code>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
01020102 032c023c 0567048c 078d06bf 08a006d9 09b307f3 09b307f3 08a006d9 078d06bf
0567048c 032c023c 01020102 00000000 00000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000 01060108 05570476 09ab07e9 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff
09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09ab07e9 05570476 01060108 00000000
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 033d0353 08a607e2 09bb07ff 09bb07ff 09bb07ff 09bb07ff
...
09bb07ff 09bb07ff 09bb07ff 09bb07ff 08a607e2 033d0353 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000 01060108 05570476 09ab07e9 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff
09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09ab07e9 05570476 01060108 00000000
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000000 00000000 01020102 032c023c 0567048c
078d06bf 08a006d9 09b307f3 09b307f3 08a006d9 078d06bf 0567048c 032c023c 01020102
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
</code></pre><p>这张文件大小为 843B 的 PNG 图片解压缩后的大小是 3600B ，是原始文件大小的 4.27 倍。那么这个 3600B 是怎么得来的呢？与图片的文件大小或者像素有什么必然的联系吗？事实上，解压缩后的图片大小与原始文件大小之间没有任何关系，而只与图片的像素有关：</p>
<pre><code>解压缩后的图片大小 = 图片的像素宽 30 * 图片的像素高 30 * 每个像素所占的字节数 4
</code></pre><p>事实上，<b>不管是 JPEG 还是 PNG 图片，都是一种压缩的位图图形格式。</b>只不过 PNG 图片是无损压缩，并且支持 alpha 通道，而 JPEG 图片则是有损压缩，可以指定 0-100% 的压缩比。值得一提的是，在苹果的 SDK 中专门提供了两个函数用来生成 PNG 和 JPEG 图片：</p>
<pre><code>// return image as PNG. May return nil if image has no CGImageRef or invalid bitmap format
UIKIT_EXTERN NSData * __nullable UIImagePNGRepresentation(UIImage * __nonnull image);

// return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)                           
UIKIT_EXTERN NSData * __nullable UIImageJPEGRepresentation(UIImage * __nonnull image, CGFloat compressionQuality);
</code></pre><p>在将磁盘中的图片渲染到屏幕之前，必须先要得到图片的原始像素数据，才能执行后续的绘制操作，这就是为什么需要对图片解压缩的原因。</p>
<h2 id="强制解压缩的原理"><a href="#强制解压缩的原理" class="headerlink" title="强制解压缩的原理"></a>强制解压缩的原理</h2><p>图片的解压缩不可避免，而我们也不想让它在主线程执行，影响我们应用的响应性，那么是否有比较好的解决方案呢？答案是肯定的。<br></p>
<p>前面已经提到了，当未解压缩的图片将要渲染到屏幕时，系统会在主线程对图片进行解压缩，而如果图片已经解压缩了，系统就不会再对图片进行解压缩。因此，也就有了业内的解决方案，在子线程提前对图片进行强制解压缩。<br></p>
<p>而强制解压缩的原理就是对图片进行重新绘制，得到一张新的解压缩后的位图。其中，用到的最核心的函数是 CGBitmapContextCreate ：<br></p>
<pre><code>/* Create a bitmap context. The context draws into a bitmap which is `width&apos;
   pixels wide and `height&apos; pixels high. The number of components for each
   pixel is specified by `space&apos;, which may also specify a destination color
   profile. The number of bits for each component of a pixel is specified by
   `bitsPerComponent&apos;. The number of bytes per pixel is equal to
   `(bitsPerComponent * number of components + 7)/8&apos;. Each row of the bitmap
   consists of `bytesPerRow&apos; bytes, which must be at least `width * bytes
   per pixel&apos; bytes; in addition, `bytesPerRow&apos; must be an integer multiple
   of the number of bytes per pixel. `data&apos;, if non-NULL, points to a block
   of memory at least `bytesPerRow * height&apos; bytes. If `data&apos; is NULL, the
   data for context is allocated automatically and freed when the context is
   deallocated. `bitmapInfo&apos; specifies whether the bitmap should contain an
   alpha channel and how it&apos;s to be generated, along with whether the
   components are floating-point or integer. */
CG_EXTERN CGContextRef __nullable CGBitmapContextCreate(void * __nullable data,
    size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow,
    CGColorSpaceRef cg_nullable space, uint32_t bitmapInfo)
    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
</code></pre><p>这个函数用于创建一个位图上下文，用来绘制一张宽 width 像素，高 height 像素的位图。这个函数的注释比较长，参数也比较难理解，但是先别着急，我们先来了解下相关的知识，然后再回过头来理解这些参数，就会比较简单了。</p>
<h3 id="Pixel-Format"><a href="#Pixel-Format" class="headerlink" title="Pixel Format"></a>Pixel Format</h3><p>位图其实就是一个像素数组，而像素格式则是用来描述每个像素的组成格式，它包括以下信息：</p>
<ol>
<li>Bits per component ：一个像素中每个独立的颜色分量使用的 bit 数；</li>
<li>Bits per pixel ：一个像素使用的总 bit 数；</li>
<li>Bytes per row ：位图中的每一行使用的字节数。</li>
</ol>
<p>有一点需要注意的是，对于位图来说，像素格式并不是随意组合的，目前只支持以下有限的 17 种特定组合：<br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/Supported%20Pixel%20Formats.png?raw=true" alt="Alta Text"></p>
<p>从上图可知，对于 iOS 来说，只支持 8 种像素格式。其中颜色空间为 Null 的 1 种，Gray 的 2 种，RGB 的 5 种，CMYK 的 0 种。换句话说，iOS 并不支持 CMYK 的颜色空间。另外，在表格的第 2 列中，除了像素格式外，还指定了 bitmap information constant ，我们在后面会详细介绍。</p>
<h3 id="Color-and-Color-Spaces"><a href="#Color-and-Color-Spaces" class="headerlink" title="Color and Color Spaces"></a>Color and Color Spaces</h3><p>上面我们提到了颜色空间，那么什么是颜色空间呢？它跟颜色有什么关系呢？在 Quartz 中，一个颜色是由一组值来表示的，比如 0, 0, 1 。而颜色空间则是用来说明如何解析这些值的，离开了颜色空间，它们将变得毫无意义。<br></p>
<p>如果不知道颜色空间，那么我们根本无法知道这些值所代表的颜色。比如 0, 0, 1 在 RGB 下代表蓝色，而在 BGR 下则代表的是红色。在 RGB 和 BGR 两种颜色空间下，绿色是相同的，而红色和蓝色则相互对调了。因此，对于同一张图片，使用 RGB 和 BGR 两种颜色空间可能会得到两种不一样的效果<br></p>
<h3 id="Color-Spaces-and-Bitmap-Layout"><a href="#Color-Spaces-and-Bitmap-Layout" class="headerlink" title="Color Spaces and Bitmap Layout"></a>Color Spaces and Bitmap Layout</h3><p>像素格式是用来描述每个像素的组成格式的，比如每个像素使用的总 bit 数。而要想确保 Quartz 能够正确地解析这些 bit 所代表的含义，我们还需要提供位图的布局信息 CGBitmapInfo ：</p>
<pre><code>typedef CF_OPTIONS(uint32_t, CGBitmapInfo) {
    kCGBitmapAlphaInfoMask = 0x1F,

    kCGBitmapFloatInfoMask = 0xF00,
    kCGBitmapFloatComponents = (1 &lt;&lt; 8),

    kCGBitmapByteOrderMask     = kCGImageByteOrderMask,
    kCGBitmapByteOrderDefault  = (0 &lt;&lt; 12),
    kCGBitmapByteOrder16Little = kCGImageByteOrder16Little,
    kCGBitmapByteOrder32Little = kCGImageByteOrder32Little,
    kCGBitmapByteOrder16Big    = kCGImageByteOrder16Big,
    kCGBitmapByteOrder32Big    = kCGImageByteOrder32Big
} CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
</code></pre><p>它主要提供了三个方面的布局信息：</p>
<ol>
<li>它主要提供了三个方面的布局信息：</li>
<li>颜色分量是否为浮点数；</li>
<li>像素格式的字节顺序。</li>
</ol>
<p>其中，alpha 的信息由枚举值 CGImageAlphaInfo 来表示：</p>
<pre><code>typedef CF_ENUM(uint32_t, CGImageAlphaInfo) {
    kCGImageAlphaNone,               /* For example, RGB. */
    kCGImageAlphaPremultipliedLast,  /* For example, premultiplied RGBA */
    kCGImageAlphaPremultipliedFirst, /* For example, premultiplied ARGB */
    kCGImageAlphaLast,               /* For example, non-premultiplied RGBA */
    kCGImageAlphaFirst,              /* For example, non-premultiplied ARGB */
    kCGImageAlphaNoneSkipLast,       /* For example, RBGX. */
    kCGImageAlphaNoneSkipFirst,      /* For example, XRGB. */
    kCGImageAlphaOnly                /* No color data, alpha data only */
};
</code></pre><p>上面的注释其实已经比较清楚了，它同样也提供了三个方面的 alpha 信息:</p>
<ol>
<li>是否包含 alpha ；</li>
<li>如果包含 alpha ，那么 alpha 信息所处的位置，在像素的最低有效位，比如 RGBA ，还是最高有效位，比如 ARGB ；</li>
<li>如果包含 alpha ，那么每个颜色分量是否已经乘以 alpha 的值，这种做法可以加速图片的渲染时间，因为它避免了渲染时的额外乘法运算。比如，对于 RGB 颜色空间，用已经乘以 alpha 的数据来渲染图片，每个像素都可以避免 3 次乘法运算，红色乘以 alpha ，绿色乘以 alpha 和蓝色乘以 alpha 。<br></li>
</ol>
<p>那么我们在解压缩图片的时候应该使用哪个值呢？根据<a href="http://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use" target="_blank" rel="external">Which CGImageAlphaInfo should we use</a>和官方文档中对 UIGraphicsBeginImageContextWithOptions 函数的讨论：<br></p>
<p>我们可以知道，当图片不包含 alpha 的时候使用 kCGImageAlphaNoneSkipFirst ，否则使用 kCGImageAlphaPremultipliedFirst 。另外，这里也提到了字节顺序应该使用 32 位的主机字节顺序 kCGBitmapByteOrder32Host ，而这个值具体是什么，我们后面再讨论。</p>
<p>至于颜色分量是否为浮点数，这个就比较简单了，直接逻辑或 kCGBitmapFloatComponents 就可以了。更详细的内容就不展开了，因为我们一般用不上这个值。</p>
<p>接下来，我们来简单地了解下像素格式的<a href="https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/ByteOrdering.html#//apple_ref/doc/uid/20001150-CJBEJBHH" target="_blank" rel="external">字节顺序</a>，它是由枚举值 <code>CGImageByteOrderInfo</code> 来表示的：</p>
<pre><code>typedef CF_ENUM(uint32_t, CGImageByteOrderInfo) {
    kCGImageByteOrderMask     = 0x7000,
    kCGImageByteOrder16Little = (1 &lt;&lt; 12),
    kCGImageByteOrder32Little = (2 &lt;&lt; 12),
    kCGImageByteOrder16Big    = (3 &lt;&lt; 12),
    kCGImageByteOrder32Big    = (4 &lt;&lt; 12)
} CG_AVAILABLE_STARTING(__MAC_10_12, __IPHONE_10_0);
</code></pre><p>它主要提供了两个方面的字节顺序信息：</p>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.B0.8F.E7.AB.AF.E5.BA.8F" target="_blank" rel="external">小端模式</a>还是<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.A4.A7.E7.AB.AF.E5.BA.8F" target="_blank" rel="external">大端模式</a>；</li>
<li>数据以 16 位还是 32 位为单位。</li>
</ol>
<p>对于 iPhone 来说，采用的是小端模式，但是为了保证应用的向后兼容性，我们可以使用系统提供的宏，来避免 <a href="https://en.wikipedia.org/wiki/Hard_coding" target="_blank" rel="external">Hardcoding</a></p>
<pre><code>#ifdef __BIG_ENDIAN__
    #define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Big
    #define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Big
#else /* Little endian. */
    #define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Little
    #define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Little
#endif
</code></pre><p>根据前面的讨论，我们知道字节顺序的值应该使用的是 32 位的主机字节顺序 <code>kCGBitmapByteOrder32Host</code> ，这样的话不管当前设备采用的是小端模式还是大端模式，字节顺序始终与其保持一致。</p>
<p>下面，我们来看一张图，它非常形象地展示了在使用 16 或 32 位像素格式的 CMYK 和 RGB 颜色空间下，一个像素是如何被表示的：<br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/pixel%20formats.png?raw=true" alt="Alta Text"></p>
<p>我们从图中可以看出，在 32 位像素格式下，每个颜色分量使用 8 位；而在 16 位像素格式下，每个颜色分量则使用 5 位。</p>
<p>好了，了解完这些相关知识后，我们再回过头来看看 <code>CGBitmapContextCreate</code> 函数中每个参数所代表的具体含义：</p>
<ol>
<li><code>data</code> ：如果不为 <code>NULL</code> ，那么它应该指向一块大小至少为 <code>bytesPerRow * height</code> 字节的内存；如果 为 <code>NULL</code> ，那么系统就会为我们自动分配和释放所需的内存，所以一般指定 <code>NULL</code> 即可；</li>
<li><code>width</code> 和 <code>height</code> ：位图的宽度和高度，分别赋值为图片的像素宽度和像素高度即可；</li>
<li><code>bitsPerComponent</code> ：像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可；</li>
<li><code>bytesPerRow</code> ：位图的每一行使用的字节数，大小至少为 <code>width * bytes per pixel</code> 字节。有意思的是，当我们指定<code>0</code> 时，系统不仅会为我们自动计算，而且还会进行 cache line alignment 的优化，更多信息可以查看 <a href="http://stackoverflow.com/questions/23790837/what-is-byte-alignment-cache-line-alignment-for-core-animation-why-it-matters" target="_blank" rel="external">what is byte alignment (cache line alignment) for Core Animation? Why it matters?</a> 和 <a href="http://stackoverflow.com/questions/15935074/why-is-my-images-bytes-per-row-more-than-its-bytes-per-pixel-times-its-width" target="_blank" rel="external">Why is my image’s Bytes per Row more than its Bytes per Pixel times its Width?</a> ，亲测可用；</li>
<li><code>space</code> ：就是我们前面提到的颜色空间，一般使用 RGB 即可；</li>
<li><code>bitmapInfo</code> ：就是我们前面提到的位图的布局信息</li>
</ol>
<h2 id="开源库的实现"><a href="#开源库的实现" class="headerlink" title="开源库的实现"></a>开源库的实现</h2><p>三个比较流行的开源库 <a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">YYKit</a> 、<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a> 和 <a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="external">FLAnimatedImage</a> 中，对图片的强制解压缩是如何实现的。</p>
<p> YYKit 中的相关代码，用于解压缩图片的函数 YYCGImageCreateDecodedCopy 存在于 YYImageCoder 类中，核心代码如下：</p>
<pre><code> CGImageRef YYCGImageCreateDecodedCopy(CGImageRef imageRef, BOOL decodeForDisplay) {
    ...

    if (decodeForDisplay) { // decode with redraw (may lose some precision)
        CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef) &amp; kCGBitmapAlphaInfoMask;

        BOOL hasAlpha = NO;
        if (alphaInfo == kCGImageAlphaPremultipliedLast ||
            alphaInfo == kCGImageAlphaPremultipliedFirst ||
            alphaInfo == kCGImageAlphaLast ||
            alphaInfo == kCGImageAlphaFirst) {
            hasAlpha = YES;
        }

        // BGRA8888 (premultiplied) or BGRX8888
        // same as UIGraphicsBeginImageContext() and -[UIView drawRect:]
        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;
        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;

        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);
        if (!context) return NULL;

        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); // decode
        CGImageRef newImage = CGBitmapContextCreateImage(context);
        CFRelease(context);

        return newImage;
    } else {
        ...
    }
}
</code></pre><p>它接受一个原始的位图参数 <code>imageRef</code> ，最终返回一个新的解压缩后的位图 <code>newImage</code> ，中间主要经过了以下三个步骤：<br></p>
<ol>
<li>使用 <code>CGBitmapContextCreate</code> 函数创建一个位图上下文；</li>
<li>使用 <code>CGContextDrawImage</code> 函数将原始位图绘制到上下文中；</li>
<li>使用 <code>CGBitmapContextCreateImage</code> 函数创建一张新的解压缩后的位图。</li>
</ol>
<p>事实上，SDWebImage 和 FLAnimatedImage 中对图片的解压缩过程与上述完全一致，只是传递给 <code>CGBitmapContextCreate</code> 函数的部分参数存在细微的差别，如下表所示：<br><img src="https://raw.githubusercontent.com/jackytianhappy/ImgSource/0619b8810cde373c9f061ad8843406f38285c56d/CGBitmapContextCreate.png" alt="Alta Text"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/01/http学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/01/http学习笔记/" itemprop="url">
                  http学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-01T15:42:34+08:00">
                2017-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>http的请求分成了三部分：请求行，请求头和请求正文<br><br></p>
<pre><code>POST /index.php HTTP/1.1
Host: localhost
User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-cn,zh;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Referer: http://localhost/
Content-Length：25
Content-Type：application/x-www-form-urlencoded
username=aa&amp;password=1234
</code></pre><h1 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h1><h2 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h2><p>请求行的格式为“方法+URL+协议/版本”,回车换行作为结尾，以空格分割。例如<br><br>POST /index.php HTTP/1.1<br><br>以上代码中“GET”代表请求方法，“//ndex.php”表示URI，“HTTP/1.1代表协议和协议的版本。<br><br>URL完整地指定了要访问的网络资源，通常只要给出相对于服务器的根目录的相对目录即可，因此总是以“/”开头，最后，协议版本声明了通信过程中使用HTTP的版本。   </p>
</blockquote>
<p>请求方法简介：<br></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>请求获取由 Request-URI 所标识的资源</td>
</tr>
<tr>
<td>POST</td>
<td>请求服务器接收在请求中封装的实体，并将其作为由 Request-Line 中Request-URL所标识的资源的一部分</td>
</tr>
<tr>
<td>HEAD</td>
<td>请求获取由 Request-URI 所标识的资源的响应消息报头</td>
</tr>
<tr>
<td>PUT</td>
<td>请求服务器存储一个资源，并用 Request-URI 作为其标识符</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除由 Request-URI 所标识的资源</td>
</tr>
<tr>
<td>TRACE</td>
<td>请求服务器回送到的请求信息，主要用于测试或诊断</td>
</tr>
<tr>
<td>CONNECT</td>
<td>保留将来使用</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>请求查询服务器的性能，或者查询与资源相关的选项和需求</td>
</tr>
</tbody>
</table>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>GET 方法用于获取由Request-URL所标识的资源的信息，常见的形式是：<br><br>GET Request-URI HTTP/1.1<br><br>GET方法是默认的HTTP请求方法，例如当我们通过在浏览器的地址栏中直接输入网址的方式去访问网页的时候，浏览器采用的就是 GET 方法向服务器获取资源。<br></p>
<p> 我们可以使用GET方法来提交表单数据，用GET方法提交的表单数据只经过了简单的编码，同时它将作为URL的一部分向服务器发送，因此，如果使用GET方法来提交表单数据就存在着安全隐患上。例如：<br><br>     Http://localhost/login.php?username=aa&amp;password=1234<br><br>    从上面的URL请求中，很容易就可以辩认出表单提交的内容。（？之后的内容）另外由于GET方法提交的数据是作为URL请求的一部分所以提交的数据量不能太大。这是因为浏览器对url的长度有限制<br><br>   各种浏览器也会对url的长度有所限制，下面是几种常见浏览器的url长度限制:(单位:字符)<br><br>      IE : 2803<br>    Firefox:65536<br>    Chrome:8182<br>    Safari:80000<br>    Opera:190000 </p>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>POST方法是GET方法的一个替代方法，它主要是向Web服务器提交表单数据，尤其是大批量的数据。 在请求头信息结束之后的两个回车换行之后（实际是空一行），就是表单提交的数据。如上面提到的post表单数据：<br><br> username=aa&amp;password=1234<br><br>    POST方法克服了GET方法的一些缺点。通过POST方法提交表单数据时，数据不是作为URL请求的一部分而是作为标准数据传送给Web服务器，这就克服了GET方法中的信息无法保密和数据量太小的缺点。因此，出于安全的考虑以及对用户隐私的尊重，通常表单提交时采用POST方法。<br><br>    从编程的角度来讲，如果用户通过GET方法提交数据，则数据存放在QUERY＿STRING环境变量中，而POST方法提交的数据则可以从标准输入流中获取。<br></p>
<h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><ol>
<li>在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放在HTTP包的body中。</li>
<li>GET方式提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST则没有此限制。</li>
<li>安全性问题。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。</li>
<li>服务器取值方式不一样。GET方式取值，如php可以使用$_GET来取得变量的值，而POST方式通过$_POST来获取变量的值。</li>
</ol>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>HEAD 方法与 GET 方法几乎是相同的，它们的区别在于 HEAD 方法只是请求消息报头，而不是完整的内容。对于 HEAD 请求的回应部分来说，它的 HTTP 头部中包含的信息与通过 GET 请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到 Request-URI 所标识的资源的信息。这个方法通常被用于测试超链接的有效性，是否可以访问，以及最近是否更新。</p>
<h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><p>每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p>
<h3 id="Transport-头域"><a href="#Transport-头域" class="headerlink" title="Transport 头域"></a>Transport 头域</h3><h4 id="Connection："><a href="#Connection：" class="headerlink" title="Connection："></a>Connection：</h4><p>如果服务器看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接）,它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，服务器需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入 ByteArrayOutputStream，然后在正式写出内容之前计算它的大小；</p>
<h4 id="Host（发送请求时，该报头域是必需的"><a href="#Host（发送请求时，该报头域是必需的" class="headerlink" title="Host（发送请求时，该报头域是必需的)"></a>Host（发送请求时，该报头域是必需的)</h4><p>Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。<br><br>eg：<a href="http://；localhost/index.html" target="_blank" rel="external">http://；localhost/index.html</a><br><br>浏览器发送的请求消息中，就会包含Host请求报头域，如下：<br><br>Host：localhost<br><br>此处使用缺省端口号80，若指定了端口号8080，则变成：Host：localhost:8080<br></p>
<h3 id="Client-头域"><a href="#Client-头域" class="headerlink" title="Client 头域"></a>Client 头域</h3><h4 id="Accept："><a href="#Accept：" class="headerlink" title="Accept："></a>Accept：</h4><p>作用：浏览器可以接受的媒体类型（MIME类型）,</p>
<p>例如：  Accept: text/html  代表浏览器可以接受服务器回发的类型为 text/html  也就是我们常说的html文档, 如果服务器无法返回text/html类型的数据，服务器应该返回一个406错误(non acceptable)。</p>
<p>通配符 <em> 代表任意类型。例如  Accept: </em>/*  代表浏览器可以处理所有类型，(一般浏览器发给服务器都是发这个)</p>
<h4 id="Accept-Encoding："><a href="#Accept-Encoding：" class="headerlink" title="Accept-Encoding："></a>Accept-Encoding：</h4><p>作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是字符编码）;</p>
<p>例如： Accept-Encoding: gzip, deflate。Server能够向支持gzip/deflate的浏览器返回经gzip或者deflate编码的HTML页面。 许多情形下这可以减少5到10倍的下载时间，也节省带宽。</p>
<h4 id="Accept-Language："><a href="#Accept-Language：" class="headerlink" title="Accept-Language："></a>Accept-Language：</h4><p>作用： 浏览器申明自己接收的语言。 </p>
<p>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；</p>
<p>例如： Accept-Language:zh-cn 。如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。</p>
<h4 id="User-Agent："><a href="#User-Agent：" class="headerlink" title="User-Agent："></a>User-Agent：</h4><p>作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.</p>
<p>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上， 服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。</p>
<p>例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)</p>
<h4 id="Accept-Charset："><a href="#Accept-Charset：" class="headerlink" title="Accept-Charset："></a>Accept-Charset：</h4><p>作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）；</p>
<p>例如：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。</p>
<p>Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中；</p>
<p>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。</p>
<h3 id="Cookie-Login-头域"><a href="#Cookie-Login-头域" class="headerlink" title="Cookie/Login 头域"></a>Cookie/Login 头域</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h4><p>作用： 最重要的header, 将cookie的值发送给HTTP 服务器</p>
<h3 id="Entity头域"><a href="#Entity头域" class="headerlink" title="Entity头域"></a>Entity头域</h3><h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length:"></a>Content-Length:</h4><p>作用：发送给HTTP服务器数据的长度。即请求消息正文的长度；</p>
<p>例如： Content-Length: 38</p>
<h4 id="Content-Type："><a href="#Content-Type：" class="headerlink" title="Content-Type："></a>Content-Type：</h4><p>作用：</p>
<p>例如：Content-Type: application/x-www-form-urlencoded</p>
<h3 id="Miscellaneous-头域"><a href="#Miscellaneous-头域" class="headerlink" title="Miscellaneous 头域"></a>Miscellaneous 头域</h3><h4 id="Refer"><a href="#Refer" class="headerlink" title="Refer:"></a>Refer:</h4><p>作用： 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里， 他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问    他的网站。</p>
<p>例如: Referer:<a href="http://translate.google.cn/?hl=zh-cn&amp;tab=wT" target="_blank" rel="external">http://translate.google.cn/?hl=zh-cn&amp;tab=wT</a></p>
<h3 id="Cache-头域"><a href="#Cache-头域" class="headerlink" title="Cache 头域"></a>Cache 头域</h3><h4 id="If-Modified-Since："><a href="#If-Modified-Since：" class="headerlink" title="If-Modified-Since："></a>If-Modified-Since：</h4><p>作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。</p>
<p>例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT。</p>
<h4 id="If-Modified-Match："><a href="#If-Modified-Match：" class="headerlink" title="If-Modified-Match："></a>If-Modified-Match：</h4><p>作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag.  使用这样的机制将提高网站的性能</p>
<p>例如: If-None-Match: “03f2b33c0bfcc1:0”</p>
<h4 id="Pragma："><a href="#Pragma：" class="headerlink" title="Pragma："></a>Pragma：</h4><p>作用： 防止页面被缓存， 在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样</p>
<p>Pargma只有一个用法， 例如： Pragma: no-cache</p>
<p>注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control</p>
<h4 id="Cache-Control："><a href="#Cache-Control：" class="headerlink" title="Cache-Control："></a>Cache-Control：</h4><p>作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下</p>
<p>Cache-Control:Public   可以被任何缓存所缓存（）</p>
<p>Cache-Control:Private     内容只缓存到私有缓存中</p>
<p>Cache-Control:no-cache  所有内容都不会被缓存</p>
<h1 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h1><blockquote>
<p>响应也是由三部分祖成，状态行、消息报头、响应正文</p>
</blockquote>
<pre><code>在接收和解释请求消息后，服务器会返回一个 HTTP 响应消息。与 HTTP 请求类似，HTTP 响应也是由三个部分组成，分别是：状态行、消息报头和响应正文。如：

HTTP/1.1 200 OK
Date: Sun, 17 Mar 2013 08:12:54 GMT
Server: Apache/2.2.8 (Win32) PHP/5.2.5
X-Powered-By: PHP/5.2.5
Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/
Expires: Thu, 19 Nov 1981 08:52:00 GMT
Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0
Pragma: no-cache
Content-Length: 4393
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: text/html; charset=utf-8


&lt;html&gt;
&lt;head&gt;
&lt;title&gt;HTTP响应示例&lt;title&gt;
&lt;/head&gt;
&lt;body&gt;
Hello HTTP!
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h2><blockquote>
<p>组成由协议版本数字形式+状态代码+状态描述 元素之间已空格分开<br><br>HTTP-Version + Status-Code + Reason-Phrase CRLF</p>
</blockquote>
<p>常用状态码解析：</p>
<ol>
<li>1xx：指示信息——表示请求已经接受，继续处理</li>
<li>2xx：成功——表示请求已经被成功接收、理解、接受。</li>
<li>3xx：重定向——要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误——客户端请求有错误或请求无法实现</li>
<li>5xx：服务器端错误——服务器未能实现合法的请求。</li>
</ol>
<p>描述：</p>
<ol>
<li>200 OK      //客户端请求成功</li>
<li>303：重定向，即从原url重定向到新的url。 例如php 的hear函数header（”localtion:/index.php”）</li>
<li>400 Bad Request  //客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </li>
<li>403 Forbidden  //服务器收到请求，但是拒绝提供服务，一般是服务器路径没有权限或者是其他权限相关问题</li>
<li>404 Not Found  //请求资源不存在，eg：输入了错误的URL</li>
<li>500 Internal Server Error //服务器发生不可预期的错误：一般来说，这个问题都会在服务器端的源代码出现错误时出现，比如出现死循环。</li>
<li>502 Bad Gateway//作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。比如LNMP ,php-fpm没有启动就会报502错误。</li>
<li>503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常，比如java 容器部署war的时候，就出现503</li>
<li>504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应，比如nginx和php-fpm， php设置sleep（200），就会收到504 Gateway Time-out。注意：某些代理服务器在DNS查询超时时会返回400或者500错误</li>
</ol>
<h2 id="消息报头"><a href="#消息报头" class="headerlink" title="消息报头"></a>消息报头</h2><p>http常见的响应头如下所示：</p>
<h3 id="Cache头域"><a href="#Cache头域" class="headerlink" title="Cache头域"></a>Cache头域</h3><h4 id="Date："><a href="#Date：" class="headerlink" title="Date："></a>Date：</h4><p>作用：生成消息的具体时间和日期，即当前的GMT时间。</p>
<p>例如：　Date: Sun, 17 Mar 2013 08:12:54 GMT</p>
<h4 id="Expires："><a href="#Expires：" class="headerlink" title="Expires："></a>Expires：</h4><p>作用: 浏览器会在指定过期时间内使用本地缓存，指明应该在什么时候认为文档已经过期，从而不再缓存它。</p>
<p>例如: Expires: Thu, 19 Nov 1981 08:52:00 GMT　　</p>
<h4 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h4><p>作用：</p>
<p>例如: Vary: Accept-Encoding</p>
<h3 id="Cookie-Login-头域-1"><a href="#Cookie-Login-头域-1" class="headerlink" title="Cookie/Login 头域"></a>Cookie/Login 头域</h3><h4 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h4><p>作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题</p>
<p>例如: P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR</p>
<p>Set-Cookie</p>
<p>作用： 非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie.</p>
<p>例如: Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/</p>
<h3 id="Entity实体头域："><a href="#Entity实体头域：" class="headerlink" title="Entity实体头域："></a>Entity实体头域：</h3><p>实体内容的属性，包括实体信息类型，长度，压缩方法，最后一次修改时间，数据有效性等</p>
<h4 id="ETag："><a href="#ETag：" class="headerlink" title="ETag："></a>ETag：</h4><p>作用:  和If-None-Match 配合使用。 （实例请看上节中If-None-Match的实例）</p>
<p>例如: ETag: “03f2b33c0bfcc1:0”</p>
<h4 id="Last-Modified："><a href="#Last-Modified：" class="headerlink" title="Last-Modified："></a>Last-Modified：</h4><p>作用： 用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例）</p>
<p>例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT</p>
<h4 id="Content-Type：-1"><a href="#Content-Type：-1" class="headerlink" title="Content-Type："></a>Content-Type：</h4><p>作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集,<br>例如:</p>
<p>   Content-Type: text/html; charset=utf-8</p>
<p>　　Content-Type:text/html;charset=GB2312</p>
<p>　　Content-Type: image/jpeg</p>
<h4 id="Content-Length："><a href="#Content-Length：" class="headerlink" title="Content-Length："></a>Content-Length：</h4><p>指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。</p>
<p>　　例如: Content-Length: 19847</p>
<h4 id="Content-Encoding："><a href="#Content-Encoding：" class="headerlink" title="Content-Encoding："></a>Content-Encoding：</h4><p>作用：文档的编码（Encode）方法。一般是压缩方式。</p>
<p>WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。利用gzip压缩文档能够显著地减少HTML文档的下载时间。</p>
<p>例如：Content-Encoding：gzip</p>
<h4 id="Content-Language："><a href="#Content-Language：" class="headerlink" title="Content-Language："></a>Content-Language：</h4><p>作用： WEB服务器告诉浏览器自己响应的对象的语言者</p>
<p>例如： Content-Language:da</p>
<h3 id="Miscellaneous-头域-1"><a href="#Miscellaneous-头域-1" class="headerlink" title="Miscellaneous 头域"></a>Miscellaneous 头域</h3><h4 id="Server："><a href="#Server：" class="headerlink" title="Server："></a>Server：</h4><p>作用：指明HTTP服务器的软件信息</p>
<p>例如:Apache/2.2.8 (Win32) PHP/5.2.5</p>
<h4 id="X-Powered-By："><a href="#X-Powered-By：" class="headerlink" title="X-Powered-By："></a>X-Powered-By：</h4><p>作用：表示网站是用什么技术开发的</p>
<p>例如： X-Powered-By: PHP/5.2.5</p>
<h3 id="Transport头域"><a href="#Transport头域" class="headerlink" title="Transport头域"></a>Transport头域</h3><h4 id="Connection：-1"><a href="#Connection：-1" class="headerlink" title="Connection："></a>Connection：</h4><p>例如：　Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p>例如：  Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p>
<h3 id="Location头域"><a href="#Location头域" class="headerlink" title="Location头域"></a>Location头域</h3><h4 id="Location："><a href="#Location：" class="headerlink" title="Location："></a>Location：</h4><p>作用： 用于重定向一个新的位置， 包含新的URL地址</p>
<p>实例请看304状态实例</p>
<font color="red">无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。<br><br>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。<br><br>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。<br><br>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</font>

<h2 id="响应正文"><a href="#响应正文" class="headerlink" title="响应正文"></a>响应正文</h2><p>响应正文就是服务器返回的资源的内容，响应头和正文之间也必须用空行分隔。如：</p>
<pre><code>&lt;html&gt;  
&lt;head&gt;  
&lt;title&gt;HTTP响应示例&lt;title&gt;  
&lt;/head&gt;  
&lt;body&gt;  
Hello HTTP!  
&lt;/body&gt;  
&lt;/html&gt;  
</code></pre><p><a href="http://www.cnblogs.com/zery/p/5164795.html" target="_blank" rel="external">HTTPS详解</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/28/nginx安装篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/28/nginx安装篇/" itemprop="url">
                  nginx rtmp 安装篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-28T16:55:00+08:00">
                2017-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。</p>
<h3 id="nginx-rtmp安装教程"><a href="#nginx-rtmp安装教程" class="headerlink" title="nginx rtmp安装教程"></a>nginx rtmp安装教程</h3><p>通过神器homebrew安装</p>
<ul>
<li>brew update 更新本地brew</li>
<li>brew install homebrew/nginx/nginx-full –with-rtmp-module<br>nginx-full代码nginx的完整版</li>
<li>查看安装后的信息brew info nginx-full</li>
</ul>
<h3 id="修改nginx的配置文件"><a href="#修改nginx的配置文件" class="headerlink" title="修改nginx的配置文件"></a>修改nginx的配置文件</h3><blockquote>
<p>通过以上nginx后的配置文件路径在/usr/local/etc/nginx下<br>修改配置文件为以下（去掉了注释部分）<br></p>
</blockquote>
<pre><code>    #user  nobody;
    worker_processes  1;

    error_log  logs/error.log debug;

    events {
        worker_connections  1024;
    }

    http {
        include       mime.types;
        default_type  application/octet-stream;

        sendfile        on;
        keepalive_timeout  65;

        server {
            listen       8080;
            server_name  localhost;

            # rtmp stat
            location /stat {
                rtmp_stat all;
                rtmp_stat_stylesheet stat.xsl;
            }
            location /stat.xsl {
                # 这个路径一定要改
                root /usr/local/Cellar/rtmp-nginx-module/1.1.7.9/share/rtmp-nginx-module;
            }

            # rtmp control
            location /control {
                rtmp_control all;
            }

            error_page   500 502 503 504  /50x.html;
            location = /50x.html {
                root   html;
            }
        }
}

rtmp {
    server {
        listen 1935;
        ping 30s;
        notify_method get;

        application myapp {
            live on;
        }
    }
}
</code></pre><p> 编辑之后通过sudo nginx -s reload重启nginx。<br> 启动方式，进入ngix的目录，如我安装的目录：/usr/local/Cellar/nginx-full/1.10.3/bin 启动 sudo ./nginx</p>
<h2 id="ffmpeg安装"><a href="#ffmpeg安装" class="headerlink" title="ffmpeg安装"></a>ffmpeg安装</h2><h3 id="ffmpeg安装教程"><a href="#ffmpeg安装教程" class="headerlink" title="ffmpeg安装教程"></a>ffmpeg安装教程</h3><ol>
<li>brew unlink ffmpeg</li>
<li><p>brew install ffmpeg –with-ffplay</p>
</li>
<li><p>访问 <a href="http://localhost:8080/stat，如果正常打开，表示你已经成功了一大半" target="_blank" rel="external">http://localhost:8080/stat，如果正常打开，表示你已经成功了一大半</a></p>
</li>
<li>cd /System/Library/Compositions/</li>
<li>ffmpeg -re -i Yosemite.mov -c copy -f flv rtmp://localhost/myapp/mystream</li>
<li>ffplay rtmp://localhost/myapp/mystream<br>开始可能会出现如下的连接错误<br>Connection to tcp://localhost:1935 failed (Connection refused), trying next address</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/24/RTMP原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/24/RTMP原理/" itemprop="url">
                  直播日记-4 RTMP原理篇章
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-24T11:13:11+08:00">
                2017-03-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h2><p>RTMP协议是Real Time Message Protocol(实时信息传输协议)的缩写，它是由Adobe公司提出的一种应用层的协议，用来解决多媒体数据传输流的多路复用（Multiplexing）和分包（packetizing）的问题。</p>
<h3 id="1-总体介绍"><a href="#1-总体介绍" class="headerlink" title="1.总体介绍"></a>1.总体介绍</h3><p>RTMP协议是应用层协议，是要靠底层可靠的传输层协议（通常是TCP）来保证信息传输的可靠性的。在基于传输层协议的链接建立完成后，RTMP协议也要客户端和服务器通过“握手”来建立基于传输层链接之上的RTMP Connection链接，在Connection链接上会传输一些控制信息，如SetChunkSize,SetACKWindowSize。<br><br>其中CreateStream命令会创建一个Stream链接，用于传输具体的音视频数据和控制这些信息传输的命令信息。RTMP协议传输时会对数据做自己的格式化，这种格式的消息我们称之为RTMP Message，而实际传输的时候为了更好地实现多路复用、分包和信息的公平性，发送端会把Message划分为带有Message ID的Chunk，每个Chunk可能是一个单独的Message，也可能是Message的一部分，在接受端会根据chunk中包含的data的长度，message id和message的长度把chunk还原成完整的Message，从而实现信息的收发。</p>
<h3 id="2-握手"><a href="#2-握手" class="headerlink" title="2.握手"></a>2.握手</h3><p>要建立一个有效的RTMP Connection链接，首先要“握手”:客户端要向服务器发送C0,C1,C2（按序）三个chunk，服务器向客户端发送S0,S1,S2（按序）三个chunk，然后才能进行有效的信息传输。RTMP协议本身并没有规定这6个Message的具体传输顺序，但RTMP协议的实现者需要保证这几点：<br></p>
<ul>
<li>客户端要等收到S1之后才能发送C2<br></li>
<li>客户端要等收到S2之后才能发送其他信息（控制信息和真实音视频等数据)<br></li>
<li>服务端要等到收到C0之后发送S1<br></li>
<li>服务端必须等到收到C1之后才能发送S2<br></li>
<li>服务端必须等到收到C2之后才能发送其他信息（控制信息和真实音视频等数据）<br><br>服务端收发的顺序如下：<br><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/RTMP-HandShake.png?raw=true" alt="Alt text"><br><br>理论上来讲只要满足以上条件，如何安排6个Message的顺序都是可以的，但实际实现中为了在保证握手的身份验证功能的基础上尽量减少通信的次数，一般的发送顺序是这样的，这一点可以通过wireshark抓ffmpeg推流包进行验证：<br><br>｜client｜Server ｜<br><br>｜－－－C0+C1—-&gt;|<br><br>｜&lt;－－S0+S1+S2– |<br><br>｜－－－C2-－－－&gt; ｜<br></li>
</ul>
<blockquote>
<p>握手的包格式<br></p>
<ol>
<li>C0与S0的格式：<br><br><font color="red">c0和s0包是一个1字节,可以看作是一个byte<br></font><br>目前rtmp版本定义为3,0-2是早期的专利产品所使用的值,现已经废弃,4-31是预留值,32-255是禁用值(这样做是为了区分基于文本的协议,因为这些协议通常都是以一个可打印的字符开始),如果服务端不能识别客户请求的版本,那么它应该发送3的响应,客户端这时可以选择下降到版本3,也可以放弃这次握手<br></li>
<li>c1与s1格式<br><br>c1与s1长度为1536个字节,它们由以下字段组成:<br><br>a. 时间戳:该字段占4字节,包含了一个时间戳,它是所有从这个端点发送出去的将来数据块的起始点,它可以是零,或是任意值,为了同步多个数据块流,端点可能会将这个字段设成其它数据块流时间戳的当前值.<br><br>0:此标记位占4字节,并且必须是0<br><br>b. 随机数:该字段占1528字节,可以是任意值,因为每个端点必须区分已经初始化的握手和对等端点初始化的握手的响应,所以这个数据要足够的随机,当然这个也不需要密码级的随机或是动态值.<br></li>
<li>c2与s2格式<br><br>c2和s2包长都是1536字节,几乎是s1和c1的回显.<br><br>4.time1<br><br>该字段占4字节,包含有对方发送过来s1或c1的时间戳<br><br>time2<br><br>该字段占4字节,包含有对方发送过来的前一个包(s1或者c1)的时间戳<br><br>随机数回显<br><br>该字段占1528字节,包含有对方发送过来的随机数据字段,每个通信端点可以使用time1和time2字段,以及当前的时间戳,来快速估计带宽和/或连接延时,但这个数值基本上没法用.<br></li>
</ol>
</blockquote>
<h3 id="3-RTMP-Chunk-Stream"><a href="#3-RTMP-Chunk-Stream" class="headerlink" title="3. RTMP Chunk Stream"></a>3. RTMP Chunk Stream</h3><p>Chunk Stream是对传输RTMP Chunk的流的逻辑上的抽象，客户端和服务器之间有关RTMP的信息都在这个流上通信。这个流上的操作也是我们关注RTMP协议的重点。</p>
<h4 id="3-1-Message-消息"><a href="#3-1-Message-消息" class="headerlink" title="3.1 Message(消息)"></a>3.1 Message(消息)</h4><p>这里的Message是指满足该协议格式的、可以切分成Chunk发送的消息，消息包含的字段如下：<br></p>
<ul>
<li>Timestamp（时间戳）：消息的时间戳，4个字节<br></li>
<li>Length(长度)：是指Message Payload（消息负载）即音视频等信息的数据的长度，3个字节<br></li>
<li>TypeId(类型Id)：消息的类型Id，1个字节<br></li>
<li>Message Stream ID（消息的流ID）：每个消息的唯一标识，划分成Chunk和还原Chunk为Message的时候都是根据这个ID来辨识是否是同一个消息的Chunk的，4个字节，并且以小端格式存储</li>
</ul>
<h4 id="3-2-Chunking-Message分块"><a href="#3-2-Chunking-Message分块" class="headerlink" title="3.2 Chunking(Message分块)"></a>3.2 Chunking(Message分块)</h4><p>RTMP在收发数据的时候并不是以Message为单位的，而是把Message拆分成Chunk发送，而且必须在一个Chunk发送完成之后才能开始发送下一个Chunk。每个Chunk中带有MessageID代表属于哪个Message，接受端也会按照这个id来将chunk组装成Message。<br><br>通过拆分，数据量较大的Message可以被拆分成较小的“Message”，这样就可以避免优先级低的消息持续发送阻塞优先级高的数据，比如在视频的传输过程中，会包括视频帧，音频帧和RTMP控制信息，如果持续发送音频数据或者控制数据的话可能就会造成视频帧的阻塞，然后就会造成看视频时最烦人的卡顿现象。同时对于数据量较小的Message，可以通过对Chunk Header的字段来压缩信息，从而减少信息的传输量。（具体的压缩方式会在后面介绍）<br><br>Chunk的默认大小是128字节，在传输过程中，通过一个叫做Set Chunk Size的控制信息可以设置Chunk数据量的最大值，在发送端和接受端会各自维护一个Chunk Size，可以分别设置这个值来改变自己这一方发送的Chunk的最大大小。大一点的Chunk减少了计算每个chunk的时间从而减少了CPU的占用率，但是它会占用更多的时间在发送上，尤其是在低带宽的网络情况下，很可能会阻塞后面更重要信息的传输。小一点的Chunk可以减少这种阻塞问题，但小的Chunk会引入过多额外的信息（Chunk中的Header），少量多次的传输也可能会造成发送的间断导致不能充分利用高带宽的优势，因此并不适合在高比特率的流中传输。在实际发送时应对要发送的数据用不同的Chunk Size去尝试，通过抓包分析等手段得出合适的Chunk大小，并且在传输过程中可以根据当前的带宽信息和实际信息的大小动态调整Chunk的大小，从而尽量提高CPU的利用率并减少信息的阻塞机率。</p>
<h4 id="3-3Chunk-Format-块格式"><a href="#3-3Chunk-Format-块格式" class="headerlink" title="3.3Chunk Format(块格式)"></a>3.3Chunk Format(块格式)</h4><p><img src="https://github.com/jackytianhappy/ImgSource/blob/master/QQ20160228-0@2x.png?raw=true" alt="Alta text"></p>
<h5 id="3-3-1-Basic-Header-基本的头信息"><a href="#3-3-1-Basic-Header-基本的头信息" class="headerlink" title="3.3.1 Basic Header(基本的头信息):"></a>3.3.1 Basic Header(基本的头信息):</h5><p>包含了chunk stream ID（流通道Id）和chunk type（chunk的类型），chunk stream id一般被简写为CSID，用来唯一标识一个特定的流通道，chunk type决定了后面Message Header的格式。Basic Header的长度可能是1，2，或3个字节，其中chunk type的长度是固定的（占2位，注意单位是位，bit），Basic Header的长度取决于CSID的大小,在足够存储这两个字段的前提下最好用尽量少的字节从而减少由于引入Header增加的数据量。<br><br>RTMP协议支持用户自定义［3，65599］之间的CSID，0，1，2由协议保留表示特殊信息。0代表Basic Header总共要占用2个字节，CSID在［64，319］之间，1代表占用3个字节，CSID在［64，65599］之间，2代表该chunk是控制信息和一些命令信息，后面会有详细的介绍。<br><br>chunk type的长度固定为2位，因此CSID的长度是（6=8-2）、（14=16-2）、（22=24-2）中的一个。<br>当Basic Header为1个字节时，CSID占6位，6位最多可以表示64个数，因此这种情况下CSID在［0，63］之间，其中用户可自定义的范围为［3，63］。<br><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/chunk-basicheader1.png?raw=true" alt="Alta text"><br><br></p>
<p><font color="red">当Basic Header为2个字节时</font>，CSID占14位，此时协议将与chunk type所在字节的其他位都置为0，剩下的一个字节来表示CSID－64，这样共有8个字节来存储CSID，8位可以表示［0，255］共256个数，因此这种情况下CSID在［64，319］，其中319=255+64。<br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/chunk-basicheader2.png?raw=true" alt="Alta text"></p>
<p><font color="red">当Basic Header为3个字节时</font>，CSID占22位，此时协议将［2，8］字节置为1，余下的16个字节表示CSID－64，这样共有16个位来存储CSID，16位可以表示［0，65535］共65536个数，因此这种情况下CSID在［64，65599］，其中65599=65535+64，<b>Basic Header是采用小端存储的方式，越往后的字节数量级越高，因此通过这3个字节每一位的值来计算CSID时，应该是:&lt;第三个字节的值&gt;x256+&lt;第二个字节的值&gt;+64</b><br><br>可以看到2个字节和3个字节的Basic Header所能表示的CSID是有交集的［64，319］，但实际实现时还是应该秉着最少字节的原则使用2个字节的表示方式来表示［64，319］的CSID。</p>
<h5 id="3-3-2-Message-Header（消息的头信息）："><a href="#3-3-2-Message-Header（消息的头信息）：" class="headerlink" title="3.3.2 Message Header（消息的头信息）："></a>3.3.2 Message Header（消息的头信息）：</h5><p>包含了要发送的实际信息（可能是完整的，也可能是一部分）的描述信息。Message Header的格式和长度取决于Basic Header的chunk type，共有4种不同的格式，由上面所提到的Basic Header中的fmt字段控制。其中第一种格式可以表示其他三种表示的所有数据，但由于其他三种格式是基于对之前chunk的差量化的表示，因此可以更简洁地表示相同的数据，实际使用的时候还是应该采用尽量少的字节表示相同意义的数据。以下按照字节数从多到少的顺序分别介绍这4种格式的Message Header。<br></p>
<p><font color="red"><b>Type＝0:</b></font><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/chunk-messageheader0.png?raw=true" alt="Alta Text"><br>type=0时Message Header占用11个字节，其他三种能表示的数据它都能表示，但在chunk stream的开始的第一个chunk和头信息中的时间戳后退（即值与上一个chunk相比减小，通常在回退播放的时候会出现这种情况）的时候必须采用这种格式。<br></p>
<ol>
<li>timestamp（时间戳）：占用3个字节，因此它最多能表示到16777215=0xFFFFFF=2<br>24-1, 当它的值超过这个最大值时，这三个字节都置为1，这样实际的timestamp会转存到Extended Timestamp字段中，接受端在判断timestamp字段24个位都为1时就会去Extended timestamp中解析实际的时间戳.<br></li>
<li>message length（消息数据的长度）：占用3个字节，表示实际发送的消息的数据如音频帧、视频帧等数据的长度，单位是字节。注意这里是Message的长度，也就是chunk属于的Message的总数据长度，而不是chunk本身Data的数据的长度。<br></li>
<li>message type id(消息的类型id)：占用1个字节，表示实际发送的数据的类型，如8代表音频数据、9代表视频数据。<br></li>
<li>msg stream id（消息的流id）：占用4个字节，表示该chunk所在的流的ID，和Basic Header的CSID一样，它采用小端存储的方式<br><br><font color="red"><b>Type＝1:</b></font><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/chunk-messageheader1.png?raw=true" alt="Alta Text"><br>type=1时Message Header占用7个字节，<font color="red">省去了表示msg stream id的4个字节，表示此chunk和上一次发的chunk所在的流相同</font>，如果在发送端只和对端有一个流链接的时候可以尽量去采取这种格式。<br><br>timestamp delta：占用3个字节，注意这里和type＝0时不同，存储的是和上一个chunk的时间差。类似上面提到的timestamp，当它的值超过3个字节所能表示的最大值时，三个字节都置为1，实际的时间戳差值就会转存到Extended Timestamp字段中，接受端在判断timestamp delta字段24个位都为1时就会去Extended timestamp中解析时机的与上次时间戳的差值。<br><br><font color="red"><b>Type＝2:</b></font><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/chunk-messageheader2.png?raw=true" alt="Alta Text"><br>type=2时Message Header占用3个字节，相对于type＝1格式又省去了表示消息长度的3个字节和表示消息类型的1个字节，表示此chunk和上一次发送的chunk所在的流、消息的长度和消息的类型都相同。余下的这三个字节表示timestamp delta，使用同type＝1<br><br><font color="red"><b>Type＝3:</b></font><br><br>0字节！！！好吧，它表示这个chunk的Message Header和上一个是完全相同的，自然就不用再传输一遍了。当它跟在Type＝0的chunk后面时，表示和前一个chunk的时间戳都是相同的。什么时候连时间戳都相同呢？就是一个Message拆分成了多个chunk，这个chunk和上一个chunk同属于一个Message。而当它跟在Type＝1或者Type＝2的chunk后面时，表示和前一个chunk的时间戳的差是相同的。比如第一个chunk的Type＝0，timestamp＝100，第二个chunk的Type＝2，timestamp delta＝20，表示时间戳为100+20=120，第三个chunk的Type＝3，表示timestamp delta＝20，时间戳为120+20=140<h5 id="3-3-3-Extended-Timestamp（扩展时间戳）："><a href="#3-3-3-Extended-Timestamp（扩展时间戳）：" class="headerlink" title="3.3.3 Extended Timestamp（扩展时间戳）："></a>3.3.3 Extended Timestamp（扩展时间戳）：</h5>上面我们提到在chunk中会有时间戳timestamp和时间戳差timestamp delta，并且它们不会同时存在，只有这两者之一大于3个字节能表示的最大数值0xFFFFFF＝16777215时，才会用这个字段来表示真正的时间戳，否则这个字段为0。扩展时间戳占4个字节，能表示的最大数值就是0xFFFFFFFF＝4294967295。当扩展时间戳启用时，timestamp字段或者timestamp delta要全置为1，表示应该去扩展时间戳字段来提取真正的时间戳或者时间戳差。注意扩展时间戳存储的是完整值，而不是减去时间戳或者时间戳差的值。<h6 id="3-3-4-Chunk-Data（块数据）："><a href="#3-3-4-Chunk-Data（块数据）：" class="headerlink" title="3.3.4 Chunk Data（块数据）："></a>3.3.4 Chunk Data（块数据）：</h6>用户层面上真正想要发送的与协议无关的数据，长度在(0,chunkSize]之间。<h5 id="3-3-5-chunk表示例1"><a href="#3-3-5-chunk表示例1" class="headerlink" title="3.3.5 chunk表示例1"></a>3.3.5 chunk表示例1</h5><img src="https://github.com/jackytianhappy/ImgSource/blob/master/sample-chunk1.png?raw=true" alt="Alta Text"><br>首先包含第一个Message的chunk的Chunk Type为0，因为它没有前面可参考的chunk，timestamp为1000，表示时间戳。type为0的header占用11个字节，假定chunkstreamId为3<127，因此basic header占用1个字节，再加上data的32个字节，因此第一个chunk共44＝11+1+32个字节。<br=""><br>第二个chunk和第一个chunk的CSID，TypeId，Data的长度都相同，因此采用Chunk Type＝2，timestamp delta＝1020-1000＝20，因此第二个chunk占用36=3+1+32个字节。<br><br>第三个chunk和第二个chunk的CSID，TypeId，Data的长度和时间戳差都相同，因此采用Chunk Type＝3省去全部Message Header的信息，占用33=1+32个字节。<br><br>第四个chunk和第三个chunk情况相同，也占用33=1+32个字节。<br><br>最后实际发送的chunk如下：<br><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/sample-chunk1-result.png?raw=true" alt="Alta Text"></127，因此basic></li>
</ol>
<h5 id="3-3-6-chunk表示例2"><a href="#3-3-6-chunk表示例2" class="headerlink" title="3.3.6 chunk表示例2"></a>3.3.6 chunk表示例2</h5><p><img src="https://github.com/jackytianhappy/ImgSource/blob/master/sample-chunk2.png?raw=true" alt="Alta Text"><br>注意到Data的Length＝307&gt;128,因此这个Message要切分成几个chunk发送，第一个chunk的Type＝0，Timestamp＝1000，承担128个字节的Data，因此共占用140=11+1+128个字节<br><br>第二个chunk也要发送128个字节，其他字段也同第一个chunk，因此采用Chunk Type＝3，此时时间戳也为1000，共占用129=1+128个字节。<br><br>第三个chunk要发送的Data的长度为307-128-128=51个字节，还是采用Type＝3，共占用1+51＝52个字节。<br><br>最后实际发送的chunk如下：<br><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/sample-chunk2-result.png?raw=true" alt="Alta Text"></p>
<h4 id="3-4-协议控制消息（Protocol-Control-Message）"><a href="#3-4-协议控制消息（Protocol-Control-Message）" class="headerlink" title="3.4 协议控制消息（Protocol Control Message）"></a>3.4 协议控制消息（Protocol Control Message）</h4><p>在RTMP的chunk流会用一些特殊的值来代表协议的控制消息，<font color="red">它们的Message Stream ID必须为0（代表控制流信息）</font>,CSID必须为2，Message Type ID可以为1，2，3，5，6，具体代表的消息会在下面依次说明。控制消息的接受端会忽略掉chunk中的时间戳，收到后立即生效。<br></p>
<ul>
<li><font color="red"><b>Set Chunk Size(Message Type ID=1):</b></font> 设置chunk中Data字段所能承载的最大字节数，默认为128B，通信过程中可以通过发送该消息来设置chunk Size的大小（不得小于128B），而且通信双方会各自维护一个chunkSize，两端的chunkSize是独立的。比如当A想向B发送一个200B的Message，但默认的chunkSize是128B，因此就要将该消息拆分为Data分别为128B和72B的两个chunk发送，如果此时先发送一个设置chunkSize为256B的消息，再发送Data为200B的chunk，本地不再划分Message，B接受到Set Chunk Size的协议控制消息时会调整的接受的chunk的Data的大小，也不用再将两个chunk组成为一个Message。<br>以下为代表Set Chunk Size消息的chunk的Data：<img src="https://github.com/jackytianhappy/ImgSource/blob/master/set-chunksize.png?raw=true" alt="Atla Text">其中第一位必须为0，chunk Size占31个位，最大可代表2147483647＝0x7FFFFFFF＝231-1，但实际上所有大于16777215=0xFFFFFF的值都用不上，因为chunk size不能大于Message的长度，表示Message的长度字段是用3个字节表示的，最大只能为0xFFFFFF。<br></li>
<li><font color="red"><b>Set Chunk Size(Message Type ID=2):</b></font>当一个Message被切分为多个chunk，接受端只接收到了部分chunk时，发送该控制消息表示发送端不再传输同Message的chunk，接受端接收到这个消息后要丢弃这些不完整的chunk。Data数据中只需要一个CSID，表示丢弃该CSID的所有已接收到的chunk。<img src="https://raw.githubusercontent.com/jackytianhappy/ImgSource/9abe6a176bc879cf1d1c6103d0cffa6b65642d33/abort%EF%BC%8Dmessage.png" alt="Alta Text"></li>
<li><font color="red"><b>Set Chunk Size(Message Type ID=3):</b></font>当收到对端的消息大小等于窗口大小（Window Size）时接受端要回馈一个ACK给发送端告知对方可以继续发送数据。窗口大小就是指收到接受端返回的ACK前最多可以发送的字节数量，返回的ACK中会带有从发送上一个ACK后接收到的字节数。<img src="https://raw.githubusercontent.com/jackytianhappy/ImgSource/ad24e24e795a3d6299e3d082846a043dd50cd150/ACK-message.png" alt="Alta Text"></li>
<li><font color="red"><b>Set Chunk Size(Message Type ID=5):</b></font>发送端在接收到接受端返回的两个ACK间最多可以发送的字节数。<img src="https://raw.githubusercontent.com/jackytianhappy/ImgSource/28d71a4d34b313d0c318640aa512ce8b0615fb25/ACK-windowsize.png" alt="Alta Text">1.Hard(Limit Type＝0):接受端应该将Window Ack Size设置为消息中的值<br>2.Soft(Limit Type=1):接受端可以讲Window Ack Size设为消息中的值，也可以保存原来的值（前提是原来的Size小与该控制消息中的Window Ack Size）<br>3.Dynamic(Limit Type=2):如果上次的Set Peer Bandwidth消息中的Limit Type为0，本次也按Hard处理，否则忽略本消息，不去设置Window Ack Size。</li>
</ul>
<h3 id="4-不同类型的RTMP-Message"><a href="#4-不同类型的RTMP-Message" class="headerlink" title="4 不同类型的RTMP Message"></a>4 不同类型的RTMP Message</h3><ul>
<li>Command Message(命令消息，Message Type ID＝17或20)：表示在客户端盒服务器间传递的在对端执行某些操作的命令消息，如connect表示连接对端，对端如果同意连接的话会记录发送端信息并返回连接成功消息，publish表示开始向对方推流，接受端接到命令后准备好接受对端发送的流信息，后面会对比较常见的Command Message具体介绍。当信息使用AMF0编码时，Message Type ID＝20，AMF3编码时Message Type ID＝17.</li>
<li>Data Message（数据消息，Message Type ID＝15或18）：传递一些元数据（MetaData，比如视频名，分辨率等等）或者用户自定义的一些消息。当信息使用AMF0编码时，Message Type ID＝18，AMF3编码时Message Type ID＝15.</li>
<li>Shared Object Message(共享消息，Message Type ID＝16或19)：表示一个Flash类型的对象，由键值对的集合组成，用于多客户端，多实例时使用。当信息使用AMF0编码时，Message Type ID＝19，AMF3编码时Message Type ID＝16.</li>
<li>Audio Message（音频信息，Message Type ID＝8）：音频数据。</li>
<li>Video Message（视频信息，Message Type ID＝9）：视频数据。</li>
<li>Aggregate Message (聚集信息，Message Type ID＝22)：多个RTMP子消息的集合</li>
<li>User Control Message Events(用户控制消息，Message Type ID=4):告知对方执行该信息中包含的用户控制事件，比如Stream Begin事件告知对方流信息开始传输。和前面提到的协议控制信息（Protocol Control Message）不同，这是在RTMP协议层的，而不是在RTMP chunk流协议层的，这个很容易弄混。该信息在chunk流中发送时，Message Stream ID=0,Chunk Stream Id=2,Message Type Id=4。<br>———下面对以上7种信息具体介绍———-　<br><h4 id="4-1-Command-Message-命令消息，Message-Type-ID＝17或20"><a href="#4-1-Command-Message-命令消息，Message-Type-ID＝17或20" class="headerlink" title="4.1 Command Message(命令消息，Message Type ID＝17或20)"></a>4.1 Command Message(命令消息，Message Type ID＝17或20)</h4>发送端发送时会带有命令的名字，如connect，TransactionID表示此次命令的标识，Command Object表示相关参数。接受端收到命令后，会返回以下三种消息中的一种：_result 消息表示接受该命令，对端可以继续往下执行流程，_error消息代表拒绝该命令要执行的操作，method name消息代表要在之前命令的发送端执行的函数名称。这三种回应的消息都要带有收到的命令消息中的TransactionId来表示本次的回应作用于哪个命令。<br><br>可以认为发送命令消息的对象有两种，一种是NetConnection，表示双端的上层连接，一种是NetStream，表示流信息的传输通道，控制流信息的状态，如Play播放流，Pause暂停。</li>
</ul>
<h4 id="4-1-1-NetConnection-Commands-连接层的命令"><a href="#4-1-1-NetConnection-Commands-连接层的命令" class="headerlink" title="4.1.1 NetConnection Commands(连接层的命令)"></a>4.1.1 NetConnection Commands(连接层的命令)</h4><p>用来管理双端之间的连接状态，同时也提供了异步远程方法调用（RPC）在对端执行某方法，以下是常见的连接层的命令：</p>
<h5 id="4-1-1-1-connect-用于客户端向服务器发送连接请求，消息的结构如下："><a href="#4-1-1-1-connect-用于客户端向服务器发送连接请求，消息的结构如下：" class="headerlink" title="4.1.1.1 connect:用于客户端向服务器发送连接请求，消息的结构如下："></a>4.1.1.1 connect:用于客户端向服务器发送连接请求，消息的结构如下：</h5><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name(命令名字)</td>
<td>String</td>
<td>命令的名字，如”connect”</td>
</tr>
<tr>
<td>Transaction ID(事务ID)</td>
<td>Number</td>
<td>恒为1</td>
</tr>
<tr>
<td>Command Object(命令包含的参数对象)</td>
<td>Object</td>
<td>键值对集合表示的命令参数</td>
</tr>
<tr>
<td>Optional User Arguments（额外的用户参数)</td>
<td>Object</td>
<td>用户自定义的额外信息</td>
</tr>
</tbody>
</table>
<p>第三个字段中的Command Object中会涉及到很多键值对，这里不再一一列出，使用时可以参考协议的官方文档。<br>消息的回应有两种，_result表示接受连接，_error表示连接失败</p>
<h5 id="4-1-1-2-Call-用于在对端执行某函数，即常说的RPC：远程进程调用，消息的结构如下："><a href="#4-1-1-2-Call-用于在对端执行某函数，即常说的RPC：远程进程调用，消息的结构如下：" class="headerlink" title="4.1.1.2 Call:用于在对端执行某函数，即常说的RPC：远程进程调用，消息的结构如下："></a>4.1.1.2 Call:用于在对端执行某函数，即常说的RPC：远程进程调用，消息的结构如下：</h5><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Procedure Name(进程名)</td>
<td>String</td>
<td>要调用的进程名称</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>上面接收到命令消息汇总的Transaction ID</td>
</tr>
<tr>
<td>Command Object</td>
<td>Object</td>
<td>命令参数</td>
</tr>
<tr>
<td>Optional Arguents</td>
<td>Object</td>
<td>用户自定</td>
<td>义参数</td>
</tr>
</tbody>
</table>
<p>如果消息中的TransactionID不为0的话，对端需要对该命令做出响应，响应的消息结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name(命令名)</td>
<td>String</td>
<td>命令的名称</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>上面接收到的命令消息中的TransactionID</td>
</tr>
<tr>
<td>Command Object</td>
<td>Object</td>
<td>命令参数</td>
</tr>
<tr>
<td>Optional Arguments</td>
<td>Object</td>
<td>用户自定义参数</td>
</tr>
</tbody>
</table>
<h6 id="4-1-1-3-Create-Stream：创建传递具体信息的通道，从而可以在这个流中传递具体信息，传输信息单元为Chunk。"><a href="#4-1-1-3-Create-Stream：创建传递具体信息的通道，从而可以在这个流中传递具体信息，传输信息单元为Chunk。" class="headerlink" title="4.1.1.3 Create Stream：创建传递具体信息的通道，从而可以在这个流中传递具体信息，传输信息单元为Chunk。"></a>4.1.1.3 Create Stream：创建传递具体信息的通道，从而可以在这个流中传递具体信息，传输信息单元为Chunk。</h6><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name(命令名)</td>
<td>String</td>
<td>“createStream”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>上面接收到的命令消息中的TransactionID</td>
</tr>
<tr>
<td>Command Object</td>
<td>Object</td>
<td>命令参数</td>
</tr>
<tr>
<td>Optional Arguments</td>
<td>Object</td>
<td>用户自定义参数</td>
</tr>
</tbody>
</table>
<h4 id="4-1-2-NetStream-Commands-流连接上的命令"><a href="#4-1-2-NetStream-Commands-流连接上的命令" class="headerlink" title="4.1.2 NetStream Commands(流连接上的命令)"></a>4.1.2 NetStream Commands(流连接上的命令)</h4><p>Netstream建立在NetConnection之上，通过NetConnection的createStream命令创建，用于传输具体的音频、视频等信息。在传输层协议之上只能连接一个NetConnection，但一个NetConnection可以建立多个NetStream来建立不同的流通道传输数据。<br><br>以下会列出一些常用的NetStream Commands，服务端收到命令后会通过onStatus的命令来响应客户端，表示当前NetStream的状态。<br><br>onStatus命令的消息结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“onStatus”</td>
</tr>
<tr>
<td>TransactionID    Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL</td>
<td>对onSatus命令来说不需要这个字段</td>
</tr>
<tr>
<td>Info Object</td>
<td>Object</td>
<td>AMF类型的Object，至少包含以下三个属性：1，“level”，String类型，可以为“warning”、”status”、”error”中的一种；2，”code”,String类型，代表具体状态的关键字,比如”NetStream.Play.Start”表示开始播流；3，”description”，String类型，代表对当前状态的描述，提供对当前状态可读性更好的解释，除了这三种必要信息，用户还可以自己增加自定义的键值对</td>
</tr>
</tbody>
</table>
<h5 id="4-1-2-1-play-播放"><a href="#4-1-2-1-play-播放" class="headerlink" title="4.1.2.1 play(播放):"></a>4.1.2.1 play(播放):</h5><p>由客户端向服务器发起请求从服务器端接受数据（如果传输的信息是视频的话就是请求开始播流），可以多次调用，这样本地就会形成一组数据流的接收者。注意其中有一个reset字段，表示是覆盖之前的播流（设为true）还是重新开始一路播放（设为false）。<br><br>play命令的结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令名</td>
<td>String</td>
<td>“play”</td>
</tr>
<tr>
<td>事务ID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>命令参数对象</td>
<td>Null</td>
<td>不需要此字段，设为空</td>
</tr>
<tr>
<td>流名称</td>
<td>String</td>
<td>要播放的流的名称</td>
</tr>
<tr>
<td>开始位置</td>
<td>Number</td>
<td>可选参数，表示从何时开始播流，以秒为单位。默认为－2，代表选取对应该流名称的直播流，即当前正在推送的流开始播放，如果对应该名称的直播流不存在，就选取该名称的流的录播版本，如果这也没有，当前播流端要等待直到对端开始该名称的流的直播。如果传值－1，那么只会选取直播流进行播放，即使有录播流也不会播放；如果传值或者正数，就代表从该流的该时间点开始播放，如果流不存在的话就会自动播放播放列表中的下一个流</td>
</tr>
<tr>
<td>周期</td>
<td>Number</td>
<td>可选参数，表示回退的最小间隔单位，以秒为单位计数。默认值为－1，代表直到直播流不再可用或者录播流停止后才能回退播放；如果传值为0，代表从当前帧开始播放</td>
</tr>
<tr>
<td>重置</td>
<td>Boolean</td>
<td>可选参数，true代表清除之前的流，重新开始一路播放，false代表保留原来的流，向本地的播放列表中再添加一条播放流</td>
</tr>
</tbody>
</table>
<h5 id="4-1-2-2-play2（播放）："><a href="#4-1-2-2-play2（播放）：" class="headerlink" title="4.1.2.2 play2（播放）："></a>4.1.2.2 play2（播放）：</h5><p>和上面的play命令不同的是，play2命令可以将当前正在播放的流切换到同样数据但不同比特率的流上，服务器端会维护多种比特率的文件来供客户端使用play2命令来切换。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“play2”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL,对onSatus命令来说不需要这个字段</td>
<td></td>
</tr>
<tr>
<td>parameters</td>
<td>Object</td>
<td>AMF编码的Flash对象，包括了一些用于描述flash.net.NetstreamPlayOptions ActionScript obejct的参数</td>
</tr>
</tbody>
</table>
<h6 id="4-1-2-3-deleteStream-删除流-："><a href="#4-1-2-3-deleteStream-删除流-：" class="headerlink" title="4.1.2.3 deleteStream(删除流)："></a>4.1.2.3 deleteStream(删除流)：</h6><p>用于客户端告知服务器端本地的某个流对象已被删除，不需要再传输此路流。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“deleteStream”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL,对onSatus命令来说不需要这个字段</td>
<td></td>
</tr>
<tr>
<td>Stream ID（流ID)</td>
<td>Number</td>
<td>本地已删除，不再需要服务器传输的流的ID</td>
</tr>
</tbody>
</table>
<h5 id="4-1-2-4-receiveAudio-接收音频"><a href="#4-1-2-4-receiveAudio-接收音频" class="headerlink" title="4.1.2.4 receiveAudio(接收音频)"></a>4.1.2.4 receiveAudio(接收音频)</h5><p>通知服务器端该客户端是否要发送音频<br>receiveAudio命令结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“receiveAudio”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL</td>
<td>对onSatus命令来说不需要这个字段</td>
</tr>
<tr>
<td>Bool Flag</td>
<td>Boolean</td>
<td>true表示发送音频，如果该值为false，服务器端不做响应，如果为true的话，服务器端就会准备接受音频数据，会向客户端回复NetStream.Seek.Notify和NetStream.Play.Start的Onstatus命令告知客户端当前流的状态</td>
</tr>
</tbody>
</table>
<h6 id="4-1-2-5-receiveVideo-接收视频-："><a href="#4-1-2-5-receiveVideo-接收视频-：" class="headerlink" title="4.1.2.5 receiveVideo(接收视频)："></a>4.1.2.5 receiveVideo(接收视频)：</h6><p>通知服务器端该客户端是否要发送视频<br>receiveVideo命令结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“receiveVideo”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL</td>
<td>对onSatus命令来说不需要这个字段</td>
</tr>
<tr>
<td>Bool Flag</td>
<td>Boolean</td>
<td>true表示发送视频，如果该值为false，服务器端不做响应，如果为true的话，服务器端就会准备接受视频数据，会向客户端回复NetStream.Seek.Notify和NetStream.Play.Start的Onstatus命令告知客户端当前流的状态</td>
</tr>
</tbody>
</table>
<h5 id="4-1-2-6-publish-推送数据-："><a href="#4-1-2-6-publish-推送数据-：" class="headerlink" title="4.1.2.6 publish(推送数据)："></a>4.1.2.6 publish(推送数据)：</h5><p>由客户端向服务器发起请求推流到服务器。<br>publish命令结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“publish”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL,对onSatus命令来说不需要这个字段</td>
<td></td>
</tr>
<tr>
<td>Publishing Name（推流的名称）</td>
<td>String    流名称｜</td>
</tr>
<tr>
<td>Publishing Type（推流类型）</td>
<td>String</td>
<td>“live”、”record”、”append”中的一种。live表示该推流文件不会在服务器端存储；record表示该推流的文件会在服务器应用程序下的子目录下保存以便后续播放，如果文件已经存在的话删除原来所有的内容重新写入；append也会将推流数据保存在服务器端，如果文件不存在的话就会建立一个新文件写入，如果对应该流的文件已经存在的话保存原来的数据，在文件末尾接着写入</td>
</tr>
</tbody>
</table>
<h5 id="4-1-2-7-seek-定位流的位置-："><a href="#4-1-2-7-seek-定位流的位置-：" class="headerlink" title="4.1.2.7 seek(定位流的位置)："></a>4.1.2.7 seek(定位流的位置)：</h5><p>定位到视频或音频的某个位置，以毫秒为单位。<br>seek命令的结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“seek”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL,对onSatus命令来说不需要这个字段</td>
<td></td>
</tr>
<tr>
<td>milliSeconds</td>
<td>Number</td>
<td>定位到该文件的xx毫秒处｜</td>
</tr>
</tbody>
</table>
<h5 id="4-1-2-8-pause（暂停）："><a href="#4-1-2-8-pause（暂停）：" class="headerlink" title="4.1.2.8 pause（暂停）："></a>4.1.2.8 pause（暂停）：</h5><p>客户端告知服务端停止或恢复播放。<br>pause命令的结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command Name</td>
<td>String</td>
<td>“pause”</td>
</tr>
<tr>
<td>TransactionID</td>
<td>Number</td>
<td>恒为0</td>
</tr>
<tr>
<td>Command Object</td>
<td>NULL,对onSatus命令来说不需要这个字段</td>
<td></td>
</tr>
<tr>
<td>Pause/Unpause Flag</td>
<td>Boolean</td>
<td>true表示暂停，false表示恢复</td>
</tr>
<tr>
<td>milliSeconds</td>
<td>Number</td>
<td>暂停或者恢复的时间，以毫秒为单位｜</td>
</tr>
</tbody>
</table>
<p>如果Pause为true即表示客户端请求暂停的话，服务端暂停对应的流会返回NetStream.Pause.Notify的onStatus命令来告知客户端当前流处于暂停的状态，当Pause为false时，服务端会返回NetStream.Unpause.Notify的命令来告知客户端当前流恢复。如果服务端对该命令响应失败，返回_error信息。</p>
<h3 id="5-代表流程"><a href="#5-代表流程" class="headerlink" title="5.代表流程"></a>5.代表流程</h3><h4 id="5-1推流流程"><a href="#5-1推流流程" class="headerlink" title="5.1推流流程"></a>5.1推流流程</h4><p><img src="https://github.com/jackytianhappy/ImgSource/blob/master/publish-flow.png?raw=true" alt="Alta Text"></p>
<h4 id="5-2-播放流程"><a href="#5-2-播放流程" class="headerlink" title="5.2 播放流程"></a>5.2 播放流程</h4><p><img src="https://github.com/jackytianhappy/ImgSource/blob/master/play-flow.png?raw=true" alt="Alta Text"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/23/h264+AAC在iOS上的实现-实战篇章 硬编码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/23/h264+AAC在iOS上的实现-实战篇章 硬编码/" itemprop="url">
                  直播日记-3 h264+AAC在iOS上的实现-实战篇章 硬编码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-23T21:44:43+08:00">
                2017-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>上篇已介绍了关于在iOS上编码的原理，本篇主要介绍如何实现iOS上的硬编码。通常实现编码的方式有两种，1.利用FFMpeg，利用CPU做视频的编码和解码，俗称软编，软解。但是该方法比较消耗cpu的资源。2.利用系统GPU或者专用处理器来对视频流进行编码，俗称硬编和硬解。<br><br>iOS自8.0之后，系统开开放了硬件编码和解码的功能。即通过Video ToolBox框架来处理。</p>
</blockquote>
<h2 id="Video-Toolbox基本数据结构"><a href="#Video-Toolbox基本数据结构" class="headerlink" title="Video Toolbox基本数据结构"></a>Video Toolbox基本数据结构</h2><ul>
<li>CVPixelBuffer:编码前和编码后的图像的数据结构</li>
<li>CMTime、CMClock和CMTImebase：时间戳相关，时间以64-bit/32-bit的形式出现</li>
<li>CMBlockBuffer：编码后，结果的图像的数据结构</li>
<li>CMVideoFormatDescription：图像存储方式，编解码器等格式描述。</li>
<li>CMSampleBuffer：存放编解码前后的视频退选哪个的容器数据结构。<br><img src="https://raw.githubusercontent.com/jackytianhappy/ImgSource/8d443fa28b169bdd117829b4f95879860cd67218/%E8%A7%86%E9%A2%91H264%E7%BC%96%E8%A7%A3%E7%A0%81%E5%89%8D%E5%90%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Alta Text"><br>编解码前后的视频图像均封装在CMSampleBuffer中，如果是编码后的图像，以CMBlockBuffe方式存储；解码后的图像，以CVPixelBuffer存储。CMSampleBuffer里面还有另外的时间信息CMTime和视频描述信息CMVideoFormatDesc。</li>
</ul>
<h2 id="硬解的使用方法"><a href="#硬解的使用方法" class="headerlink" title="硬解的使用方法"></a>硬解的使用方法</h2><p>1.将网络传输的h264码流转换成视频码流，</p>
<font color="red">未完待续</font>










          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/23/h264+AAC在iOS上的实现-原理篇章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/23/h264+AAC在iOS上的实现-原理篇章/" itemprop="url">
                  直播日记-2 h264+AAC在iOS上的实现-原理篇章
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-23T15:51:48+08:00">
                2017-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>为什么要使用h264+AAC去编码？因为HLS是社交类直播APP的刚需，使用HLS必须通过h264+AAC的编码去实现</p>
</blockquote>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><p>H.264<br><br>H.264，又称为MPEG-4第10部分，高级视频编码（英语：MPEG-4 Part 10, Advanced Video Coding，缩写为MPEG-4 AVC）是一种面向块的基于运动补偿的视频编码标准.<a href="https://zh.wikipedia.org/wiki/H.264/MPEG-4_AVC" target="_blank" rel="external"> Form wiki </a></p>
</li>
<li><p>AAC<br><br>高级音频编码（英语：Advanced Audio Coding，AAC），出现于1997年，基于MPEG-2的音频编码技术。<a href="https://zh.wikipedia.org/wiki/%E9%80%B2%E9%9A%8E%E9%9F%B3%E8%A8%8A%E7%B7%A8%E7%A2%BC" target="_blank" rel="external">From wiki</a></p>
<p> AAC编码的主要扩展名有三种：.aac .mp4 .m4a</p>
</li>
</ul>
<h1 id="h264编码原理详解"><a href="#h264编码原理详解" class="headerlink" title="h264编码原理详解"></a>h264编码原理详解</h1><h2 id="h264的原理"><a href="#h264的原理" class="headerlink" title="h264的原理"></a>h264的原理</h2><p>H264是一种新的基于运动补偿的视频编码标准。据统计，一组连续的画面中，有差别的点只在10%以内，亮度的变化差值不超过2%，色度变化的差值不超过1%。<br><strong>因此，对于一段变化不大的图像画面，我们可以先编码出完整的图像A帧，随后的B帧就不编码全部的图像，只编码与A有差别的部分，这样B的大小就只要A的十分之一，甚至更小</strong>。<br><br>B帧之后的C帧如果变化不大，我们可以继续以参考B的方式编码C帧，这样循环下去。<br><br><strong>这段图像我们称为一个<font color="red">序列</font>（序列就是有相同特点的一段数据）</strong>,当某个图像与之前的图像变化很大，无法参考前面的帧来生成，那我们就结束上一个序列，开始下一段序列，也就是对这个图像生成一个完整帧A1，随后的图像就参考A1生成，只写入与A1的差别内容。</p>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><blockquote>
<p>上小节提出了序列的概念。为了能够更好的了解序列，我们需要知道这样的几个概念</p>
</blockquote>
<ul>
<li><p>I帧 <br><br>1.它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输; <br><br>2.解码时仅用I帧的数据就可重构完整图像; <br><br>3.I帧描述了图像背景和运动主体的详情;<br><br>4.I帧不需要参考其他画面而生成; <br><br>5.I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量); <br><br>6.I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧; <br><br>7.I帧不需要考虑运动矢量; <br><br>8.I帧所占数据的信息量比较大。<br></p>
</li>
<li><p>P帧<br><br>前向预测编码帧。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）。<br><br><font color="green">P帧的预测与重构:</font>P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。<br><br><font color="green">P帧特点:</font> <br><br>1.P帧是I帧后面相隔1~2帧的编码帧; <br><br>2.P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差); <br><br>3.解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像; <br><br>4.P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧; <br><br>5.P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧; <br><br>6.由于P帧是参考帧,它可能造成解码错误的扩散; <br><br>7.由于是差值传送,P帧的压缩比较高。 <br></p>
</li>
<li><p>B帧<br><br>双向预测内插编码帧。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累。<br><br><font color="green">B帧的预测与重构:</font>B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。<br><br><font color="green">B帧特点:</font><br>1.B帧是由前面的I或P帧和后面的P帧来进行预测的;<br>2.B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;<br>3.B帧是双向预测编码帧;<br>4.B帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;<br>5.B帧不是参考帧,不会造成解码错误的扩散。 </p>
</li>
</ul>
<blockquote>
<p>Note:I、B、P各帧是根据压缩算法的需要，是人为定义的,它们都是实实在在的物理帧。一般来说，<font color="red"><br>I帧的压缩率是7（跟JPG差不多），P帧是20，B帧可以达到50。</font>可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。</p>
</blockquote>
<h2 id="h264压缩方法"><a href="#h264压缩方法" class="headerlink" title="h264压缩方法"></a>h264压缩方法</h2><blockquote>
<p>以上的概念介绍几本阐述了h264的压缩算法.<br></p>
</blockquote>
<ul>
<li>分组:把几帧图像分为一组(GOP，也就是一个序列),为防止运动变化,帧数不宜取多。 </li>
<li>定义帧:将每组内各帧图像定义为三种类型,即I帧、B帧和P帧; </li>
<li>预测帧:以I帧做为基础帧,以I帧预测P帧,再由I帧和P帧预测B帧; </li>
<li>数据传输:最后将I帧数据与预测的差值信息进行存储和传输。</li>
</ul>
<p><strong>帧内（Intraframe）压缩</strong>也称为空间压缩（Spatial compression）。当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息，这实际上与静态图像压缩类似。帧内一般采用有损压缩算法，由于帧内压缩是编码一个完整的图像，所以可以独立的解码、显示。帧内压缩一般达不到很高的压缩，跟编码jpeg差不多。<br></p>
<p> <strong>帧间（Interframe）压缩的原理</strong>是：相邻几帧的数据有很大的相关性，或者说前后两帧信息变化很小的特点。也即连续的视频其相邻帧之间具有冗余信息,根据这一特性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比。帧间压缩也称为时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的。帧差值（Frame differencing）算法是一种典型的时间压缩法，它通过比较本帧与相邻帧之间的差异，仅记录本帧与其相邻帧的差值，这样可以大大减少数据量</p>
<blockquote>
<p>Note：<strong>有损（Lossy ）压缩和无损（Lossy less）压缩</strong>。无损压缩也即压缩前和解压缩后的数据完全一致。多数的无损压缩都采用RLE行程编码算法。有损压缩意味着解压缩后的数据与压缩前的数据不一致。在压缩的过程中要丢失一些人眼和人耳所不敏感的图像或音频信息,而且丢失的信息不可恢复。几乎所有高压缩的算法都采用有损压缩,这样才能达到低数据率的目标。丢失的数据率与压缩比有关,压缩比越小，丢失的数据越多,解压缩后的效果一般越差。此外,某些有损压缩算法采用多次重复压缩的方式,这样还会引起额外的数据丢失。</p>
</blockquote>
<h2 id="H264编码格式"><a href="#H264编码格式" class="headerlink" title="H264编码格式"></a>H264编码格式</h2><p><font color="red">H.264 的功能分为两层：视频编码层（VCL, Video Coding Layer）和网络提取层（NAL,Network Abstraction Layer）。</font><br><br>VCL 数据即编码处理的输出，它表示被压缩编码后的视频数据 序列。在 VCL 数据传输或存储之前，这些编码的 VCL 数据，先被映射或封装进 NAL 单元(以下简称 NALU，Nal Unit) 中。每个 NALU 包括一个原始字节序列负荷(RBSP, Raw Byte Sequence Payload)、一组 对应于视频编码的 NALU 头部信息。RBSP 的基本结构是:在原始编码数据的后面填加了结尾 比特。一个 bit“1”若干比特“0”，以便字节对齐。<br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/1073278-9e616be55d13e9af.png?raw=true" alt="Alta Text"></p>
<p><font color="red">上图中的 NALU头 + RBSP 就相当与一个 NALU (Nal Unit),</font> 每个单元都按独立的 NALU 传送。 其实说白了，H.264 中的结构全部都是以 NALU 为主的，理解了 NALU，就理解 H.264 的结构了。</p>
<h3 id="NALU结构详细"><a href="#NALU结构详细" class="headerlink" title="NALU结构详细"></a>NALU结构详细</h3><blockquote>
<p>NALU如何由一帧一帧的变化而来？<br>一帧图片经过 H.264 编码器之后，就被编码为一个或多个片（slice），而装载着这些片（slice）的载体，就是 NALU 了，我们可以来看看 NALU 跟片的关系（slice）。<br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/%E5%B8%A7%E5%88%87%E7%89%87.png?raw=true" alt="Alta Text"><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/%E5%B8%A7%E5%88%87%E7%89%871.png?raw=true" alt="Alta Text"><br>片（slice）的概念不同与帧（frame），帧（frame）是用作描述一张图片的，一帧（frame）对应一张图片，而片（slice），是 H.264 中提出的新概念，是通过编码图片后切分通过高效的方式整合出来的概念，一张图片至少有一个或多个片（slice）。<br><br>片（slice）都是由NALU 装载并进行网络传输的，但是这并不代表 NALU 内就一定是切片，这是充分不必要条件，因为 NALU 还有可能装载着其他用作描述视频的信息。</p>
<h4 id="NALU"><a href="#NALU" class="headerlink" title="NALU"></a>NALU</h4><p>NALU由NAL头和RBSP组成：</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/23/直播中常用的协议简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/23/直播中常用的协议简介/" itemprop="url">
                  直播日记-1 直播中常用的协议简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-23T14:16:38+08:00">
                2017-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文主要介绍直播中常用的协议,RTMP,HLS,HDL(HTTP—FLV),RTP协议，后续文章会针对RTMP进行详细的介绍。</p>
</blockquote>
<h2 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h2><p>国外大部分CDN已不支持，多内流行度非常高，主要原因如下：<br>1.开源软件和开源库的支持相对比较完整。服务端有ngix-rtmp插件，开源的librtmp等。<br><br>2.播放端安装率高。只要浏览器支持FlashPlayer，非常简单的就能支持RTMP（关于RTMP的详细介绍 后文会进行详细的解读），RTMP是传输层协议，底层通过TCP实现，使用RTMP协议会根据网络状况带来首开100ms的延迟，<font color="green"><strong>内容延迟大概有2-5秒</strong></font>。<br></p>
<h2 id="HTTP-FLV"><a href="#HTTP-FLV" class="headerlink" title="HTTP-FLV"></a>HTTP-FLV</h2><p>即通过http进行流媒体的传输。相比如RTMP，HTTP更为简单和广为人知，不必担心被Adobe的专利问题，RTMP为Adobe的专利协议。<font color="green"><strong>内容延迟大概有2-5秒</strong></font>，打开速度更快，http协议本身不存在复杂的状态交互。从延迟角度来讲，HTTP-FLV的延迟要小于RTMP的延迟。</p>
<h2 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h2><p>即HTTP Live Streaming，有苹果提出，基于HTTP的路媒体传输协议。HLS有一个显著的有点，<font color="green"><strong>能够通过HTML5直接打开</strong></font>，意味着能够通过微信等社交软件进行分析，对于涉及哦啊类型的app来说是一个刚需要。<br><br><br>基于HLS的直播流URL是一个<font color="green"><strong>m3u8</strong></font>的文件，里面包含了若干个小视频TS(一种视频封装格式)<br></p>
<p><img src="https://github.com/jackytianhappy/ImgSource/blob/master/m3u8%20ts.jpg?raw=true" alt="Atl text"></p>
<p>假设列表里面的包含5个TS文件，每个TS文件包含5秒的视频内容，那么整体的延迟就是25秒。当然可以缩短列表的长度和单个TS文件的大小来降低延迟，极致来说可以缩减列表长度为1，1秒内容的m3u8文件，但是极易受网络波动影响造成卡顿。</p>
<h2 id="RTP"><a href="#RTP" class="headerlink" title="RTP"></a>RTP</h2><p>即Real-Time Transport Protocal，用于针对对媒体数据流的一种<font color="green"><strong>传输层协议</strong></font>。<br><br>实际使用过程中需要<font color="green"><strong>RTCP（rtp control protocal）</strong></font>来配合我使用，可以简单理解为RTCP传输交互控制的信令，RTP传输实际的媒体数据。<br></p>
<p><font color="green"><strong>RTP在视频监控、视频会议、IP电话上有广泛的应用</strong></font>，因为视频会议、IP电话的一个重要的使用体验：内容实时性强。</p>
<p>RTP相对于HLS和FLV使用UDP协议来传输数据，而RTMP和HTTP是基于TCP协议传输。<br></p>
<p><font color="green"><strong>UDP：单个数据报，不用建立连接，简单，不可靠，会丢包，会乱序；<br><br>TCP：流式，需要建立连接，复杂，可靠 ，有序。</strong></font><br><br><br>实时音视频流的场景不需要可靠保障，因此也不需要有重传的机制，实时的看到图像声音，网络抖动时丢了一些内容，画面模糊和花屏，完全不重要。TCP为了重传会造成延迟与不同步，如某一截内容因为重传，导致1秒以后才到，那么整个对话就延迟了1秒，随着网络抖动，延迟还会增加成2秒、3秒，如果客户端播放是不加以处理将严重影响直播的体验。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>协议名称</th>
<th>延迟</th>
<th>优点</th>
</tr>
</thead>
<tbody>
<tr>
<td>RTMP</td>
<td>2-5秒</td>
<td>成熟框架比较多</td>
</tr>
<tr>
<td>HTTP-FLV</td>
<td>2-5秒</td>
<td>打开速度快，通内容延迟，打开速度快于rtmp</td>
</tr>
<tr>
<td>HLS</td>
<td>5-7秒</td>
<td>能够直接H5打开，社交直播刚需</td>
</tr>
<tr>
<td>RTP</td>
<td>1S内的直播延迟</td>
<td>国内CDN支持厂商较少</td>
</tr>
</tbody>
</table>
<blockquote>
<p>ps:HLS，优点明显，H5直接打开，缺点内容延迟过高，同时支持HLS的必须是H264+AAC编码。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Jacky Tian" />
          <p class="site-author-name" itemprop="name">Jacky Tian</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jacky Tian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  






  





  

  

  

  

</body>
</html>
