<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Jakcy’s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jakcy’s Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jakcy’s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Jakcy’s Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jakcy’s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">第一个博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/08/mac端ffmpeg安装教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/08/mac端ffmpeg安装教程/" itemprop="url">
                  mac端ffmpeg安装教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-08T14:38:04+08:00">
                2017-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>通过homebrew安装，未安装的homebrew的自行google</p>
</blockquote>
<h1 id="一、安装ffmpeg"><a href="#一、安装ffmpeg" class="headerlink" title="一、安装ffmpeg"></a>一、安装ffmpeg</h1><ol>
<li><p>安装ffmepeg</p>
<pre><code>brew install ffmpeg
</code></pre></li>
<li><p>查看ffmpeg信息</p>
<pre><code>brew info ffmpeg
</code></pre></li>
<li><p>升级ffmpeg</p>
<pre><code>brew update &amp;&amp; brew upgrade ffmpeg
</code></pre></li>
</ol>
<h1 id="二、使用教程"><a href="#二、使用教程" class="headerlink" title="二、使用教程"></a>二、使用教程</h1><p>将某种格式的视频转化成另一种格式的视频</p>
<pre><code>ffmpeg -i test.flv -b:v 640k test.mp4
</code></pre><p>最终实现的效果图<br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/ffmpeg%E8%BD%AC%E7%A0%81%E5%B7%A5%E5%85%B7.png?raw=true" alt="Alta Text"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/30/利用ffmpeg和x264将iOS摄像头实时视频流转化为h264/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/30/利用ffmpeg和x264将iOS摄像头实时视频流转化为h264/" itemprop="url">
                  利用ffmpeg和x264将iOS摄像头实时视频流转化为h264
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-30T16:47:34+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-编译x264库"><a href="#1-编译x264库" class="headerlink" title="1.编译x264库"></a>1.编译x264库</h1><blockquote>
<p>x264是一种免费的、具有更优秀算法的符合H.264/MPEG-4 AVC视频压缩编码标准格式的编码库。<br>从iOS8开始，苹果开放了硬解码和硬编码API，框架为 VideoToolbox.framework， 此框架需要在iOS8及以上的系统上才能使用。</p>
</blockquote>
<p>编译x264库的过程</p>
<p>1.编译X264的一个靠谱的脚本为<a href="https://github.com/kewlbear/x264-ios" target="_blank" rel="external">https://github.com/kewlbear/x264-ios</a>.使用该脚本有个不方便的，就是要先下载X264并解压好，同时要下载<a href="https://github.com/libav/gas-preprocessor" target="_blank" rel="external">https://github.com/libav/gas-preprocessor</a>并将gas-preprocessor.pl拷贝到/usr/local/bin/下，并且赋予管理员权限，才能启动脚本进行编译。<br>为了使用脚本一步到位得到X264静态库，使用一步到位的编译库感谢这位作者贡献<a href="http://depthlove.github.io/2015/09/16/build-X264-library-for-iOS-platform/" target="_blank" rel="external">http://depthlove.github.io/2015/09/16/build-X264-library-for-iOS-platform/</a>。执行一次性到位的脚本就可可以了</p>
<p><a href="http://blog.sina.com.cn/s/blog_47522f7f0102vcbj.html" target="_blank" rel="external">编译x264</a></p>
<h1 id="2-将x264库编译进FFmpeg库"><a href="#2-将x264库编译进FFmpeg库" class="headerlink" title="2.将x264库编译进FFmpeg库"></a>2.将x264库编译进FFmpeg库</h1><p><a href="http://www.cnblogs.com/sunminmin/p/4463741.html#3195954" target="_blank" rel="external">如何编译参考这篇文章</a></p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>下载编译FFmpeg所需要的脚本文件gas-preprocessor.pl，<a href="https://github.com/mansr/gas-preprocessor" target="_blank" rel="external">下载地址</a> 。在mac终端中使用cp命令将脚本文件gas-preprocessor.pl复制到 /usr/bin/目录，并赋予可执行权限。执行命令为：</p>
<p>（1）sudo cp -f /‘pwd’/gas-preprocessor.pl /usr/bin/   （备注：/‘pwd’/ 是脚本gas-preprocessor.pl所在的路径）</p>
<p>（2）chmod +x /usr/bin/gas-preprocessor.pl</p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>根据实际项目需要修改build-ffmpeg.sh脚本中的<font color="red">FFmpeg和iOS SDK版本（FFmpeg和iOS SDK的版本这里，需要根据实际情况修改build-ffmpeg.sh脚本）</font>。运行build-ffmpeg.sh脚本</p>
<blockquote>
<p>注意:</p>
<p>要将x264编译进FFmpeg中，需要取消对该句代码的注销</p>
</blockquote>
<pre><code>X264=`pwd`/fat-x264
</code></pre><p>&gt;</p>
<blockquote>
<p>修改脚本中</p>
<pre><code>CFLAGS=&quot;$CFLAGS -mios-version-min=$DEPLOYMENT_TARGET -fembed-bitcode&quot;
</code></pre><p>为</p>
<pre><code>CFLAGS=&quot;$CFLAGS -mios-version-min=$DEPLOYMENT_TARGET&quot;
</code></pre><p>查看iOS sdk版本</p>
<pre><code>cd /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/developer/SDKs/
</code></pre></blockquote>
<h1 id="3-编译库重要总结"><a href="#3-编译库重要总结" class="headerlink" title="3.编译库重要总结"></a>3.编译库重要总结</h1><ol>
<li>编译得到 x264 静态库</li>
<li>将存放x264静态库（头文件，库文件）的文件夹名称改为 fat-x264 （因为编译FFmpeg的脚本中定义存放x264文件的文件夹名称为fat-x264</li>
<li>修改编译FFmpeg的脚本build-ffmpeg.sh</li>
<li>将编译FFmpeg的脚本build-ffmpeg.sh 与 fat-x264 存放到同一个目录下</li>
<li>在Mac终端执行脚本build-ffmpeg.sh</li>
<li>最后x264静态库，支持x264的FFmpeg静态库，内容如下<br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/ffmpeg.png?raw=true" alt="Alta text"><br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/ffmpeg2.png?raw=true" alt="Alta text"></li>
</ol>
<h1 id="4-获取iOS设备摄像头实时视频"><a href="#4-获取iOS设备摄像头实时视频" class="headerlink" title="4.获取iOS设备摄像头实时视频"></a>4.获取iOS设备摄像头实时视频</h1><h1 id="5-采用x264和FFmpeg对iOS实时视频流编码为h264"><a href="#5-采用x264和FFmpeg对iOS实时视频流编码为h264" class="headerlink" title="5.采用x264和FFmpeg对iOS实时视频流编码为h264"></a>5.采用x264和FFmpeg对iOS实时视频流编码为h264</h1><h1 id="6-完整的代码下载地址"><a href="#6-完整的代码下载地址" class="headerlink" title="6.完整的代码下载地址"></a>6.完整的代码下载地址</h1><h1 id="备用fmmpeg地址"><a href="#备用fmmpeg地址" class="headerlink" title="备用fmmpeg地址"></a>备用fmmpeg地址</h1><p><a href="http://www.cocoachina.com/bbs/read.php?tid=299463?" target="_blank" rel="external">下载地址</a></p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ol>
<li><a href="http://blog.csdn.net/fernandowei/article/details/50520137" target="_blank" rel="external">GNU assembler not found, install/update gas-preprocessor解决方案</a></li>
</ol>
<h5 id="detial"><a href="#detial" class="headerlink" title="detial"></a><a href="https://depthlove.github.io/2015/09/18/use-ffmpeg-and-x264-encode-iOS-camera-video-to-h264/" target="_blank" rel="external">detial</a></h5>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/30/iOS内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/30/iOS内存管理/" itemprop="url">
                  iOS内存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-30T10:06:55+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>内存管理的原理：当我们在工程中实例化一个对象之后，通常会有一个变量来引用这个对象，当这个引用变量不在使用的时候，这时候就需要将此对象释放掉，简单的说就是：当一个对象没有被任何变量引用时，就将其回收；</p>
</blockquote>
<h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><p>每个对象内部都有一个与之对应的整数，这个整数就是“引用计数器”，当一个对象在创建之后，他的引用计数器为1，当调用这个对象的alloc、retain、new、copy方法之后，引用计数器会在原来的基础上进行加1，（在Objc中，调用一个对象方法就是给这个对象发送一个消息），当调用这个对象的release方法之后，它的引用计数会减1，如果一个对象的引用计数器为0，则系统就会自动调用这个对象的dealloc 方法来销毁这个对象。在代码中，一般使用dealloc方法来查看一个对象是否被回收，如果没有被回收，则有可能会造成内存泄露。如果确认一个对象已经被释放，那么最后需要将他的变量手动设置为nil，否则可能会造成野指针错误，需要注意的是，在Objc中，给空对象发送消息是不会报错的；</p>
<h1 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h1><p>在MRC的内存管理模式下，与对变量的管理相关的方法有：retain,release和autorelease。retain和release方法操作的是引用记数，当引用记数为零时，便自动释放内存。并且可以用NSAutoreleasePool对象，对加入自动释放池（autorelease调用）的变量进行管理，当drain时回收内存。</p>
<ol>
<li>retain，该方法的作用是将内存数据的所有权附给另一指针变量，引用数加1，即retainCount+= 1;</li>
<li>release，该方法是释放指针变量对内存数据的所有权，引用数减1，即retainCount-= 1;</li>
<li>autorelease，该方法是将该对象内存的管理放到autoreleasepool中。</li>
</ol>
<font color="red">@property (nonatomic/atomic,retain/assign/copy, readonly/readwrite) Number* num;</font>


<h1 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h1><p>在ARC中与内存管理有关的标识符，可以分为变量标识符和属性标识符，对于变量默认为__strong，而对于属性默认为unsafe_unretained。也存在autoreleasepool。</p>
<font color="red">@property (nonatomic/atomic, assign/retain/strong/weak/unsafe_unretained/copy,readonly/readwrite) Number* num;</font>

<p>其中assign/retain/copy与MRC下property的标识符意义相同，strong类似与retain,assign类似于unsafe_unretained，strong/weak/unsafe_unretained与ARC下变量标识符意义相同，只是一个用于属性的标识，一个用于变量的标识(带两个下划短线__)。所列出的其他的标识符与MRC下意义相同。</p>
<h1 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h1><h2 id="Autorelease对象什么时候释放？"><a href="#Autorelease对象什么时候释放？" class="headerlink" title="Autorelease对象什么时候释放？"></a>Autorelease对象什么时候释放？</h2><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">sunny关于Autorelease详解</a><br>关于文章里的demo和文章不相匹配的问题，这边重新写了个demo，证明viewdidappear和viewdidload确实是在两个不同的runloop里面。<br><a href="https://github.com/jackytianhappy/LearingiOSDemo/tree/master/MemoryDemo" target="_blank" rel="external">Jacky’s Demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/19/ReactNative原理详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/19/ReactNative原理详解/" itemprop="url">
                  ReactNative原理详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-19T17:27:31+08:00">
                2017-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>背景介绍：iOS APP审核周期长，通过简易的JSON配置能够去渲染不同的界面，进而实现动态页面的配置</p>
</blockquote>
<h1 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h1><p>React Native是前端和移动端的融合</p>
<h2 id="融合"><a href="#融合" class="headerlink" title="融合"></a>融合</h2><p>移动端通过 JSON 文件传递信息的不足之处：只能传递配置信息，无法表达逻辑。从本质上讲，这是因为 JSON 毕竟只是纯文本，它缺乏像编程语言那样的运行能力。</p>
<p>而 React 在前端取得突破性成功以后，JavaScript 布道者们开始试图一统三端。他们利用了移动平台能够运行 JavaScript 代码的能力，并且发挥了 JavaScript 不仅仅可以传递配置信息，还可以表达逻辑信息的优点。</p>
<p>当痛点遇上特点，两者一拍即合，于是乎：</p>
<blockquote>
<p>一个基于 JavaScript，具备动态配置能力，面向前端开发者的移动端开发框架，React Native，诞生了！</p>
</blockquote>
<h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>React Native 不是黑科技，我们写的代码总是以一种非常合理，可以解释的方式的运行着，只是绝大多数人没有理解而已。接下来我以 iOS 平台为例，简单的解释一下 React Native 的原理。</p>
<p>首先要明白的一点是，即使使用了 React Native，我们依然需要 UIKit 等框架，调用的是 Objective-C 代码。总之，JavaScript 只是辅助，它只是提供了配置信息和逻辑的处理结果。React Native 与 Hybrid 完全没有关系，它只不过是以 JavaScript 的形式告诉 Objective-C 该执行什么代码。</p>
<p>其次，React Native 能够运行起来，全靠 Objective-C 和 JavaScript 的交互。对于没有接触过 JavaScript 的人来说，非常有必要理解 JavaScript 代码如何被执行。</p>
<p> C 系列的语言，经过编译，链接等操作后，会得到一个二进制格式的可执行文，所谓的运行程序，其实是运行这个二进制程序。</p>
<p> 苹果提供了一个叫做 JavaScript Core 的框架，这是一个 JavaScript 引擎。通过下面这段代码可以简单的感受一下 Objective-C 如何调用 JavaScript 代码：</p>
<pre><code> JSContext *context = [[JSContext alloc] init];
JSValue *jsVal = [context evaluateScript:@&quot;21+7&quot;];
int iVal = [jsVal toInt32];
</code></pre><p>JavaScript 是一种单线程的语言，它不具备自运行的能力，因此总是被动调用。很多介绍 React Native 的文章都会提到 “JavaScript 线程” 的概念，实际上，它表示的是 Objective-C 创建了一个单独的线程，这个线程只用于执行 JavaScript 代码，而且 JavaScript 代码只会在这个线程中执行。</p>
<h1 id="Objective-C-与-JavaScript-交互"><a href="#Objective-C-与-JavaScript-交互" class="headerlink" title="Objective-C 与 JavaScript 交互"></a>Objective-C 与 JavaScript 交互</h1><p>提到 Objective-C 与 JavaScript 的交互，不得不推荐 bang神的这篇文章：<a href="http://blog.cnbang.net/tech/2698/" target="_blank" rel="external">React Native通信机制详解</a> 。虽然其中不少细节都已经过时，但是整体的思路值得学习。</p>
<p>本节主要分析 Objective-C 与 JavaScript 交互时的整理逻辑与流程，下一节将通过源码来分析具体原理。</p>
<h2 id="JavaScript-调用-Objective-C"><a href="#JavaScript-调用-Objective-C" class="headerlink" title="JavaScript 调用 Objective-C"></a>JavaScript 调用 Objective-C</h2><p>由于 JavaScript Core 是一个面向 Objective-C 的框架，在 Objective-C 这一端，我们对 JavaScript 上下文知根知底，可以很容易的获取到对象，方法等各种信息，当然也包括调用 JavaScript 函数。</p>
<p>真正复杂的问题在于，JavaScript 不知道 Objective-C 有哪些方法可以调用。</p>
<p>React Native 解决这个问题的方案是在 Objective-C 和 JavaScript 两端都保存了一份配置表，里面标记了所有 Objective-C 暴露给 JavaScript 的模块和方法。这样，无论是哪一方调用另一方的方法，实际上传递的数据只有 ModuleId、MethodId 和 Arguments 这三个元素，它们分别表示类、方法和方法参数，当 Objective-C 接收到这三个值后，就可以通过 runtime 唯一确定要调用的是哪个函数，然后调用这个函数。</p>
<p>上述解决方案只是一个抽象概念，可能与实际的解决方案有微小差异，比如实际上 Objective-C 这一端，并没有直接保存这个模块配置表。具体实现将在下一节中随着源码一起分析。</p>
<h2 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h2><p>既然说到函数互调，那么就不得不提到回调了。对于 Objective-C 来说，执行完 JavaScript 代码再执行 Objective-C 回调毫无难度，难点依然在于 JavaScript 代码调用 Objective-C 之后，如何在 Objective-C 的代码中，回调执行 JavaScript 代码。</p>
<p>目前 React Native 的做法是：在 JavaScript 调用 Objective-C 代码时，注册要回调的 Block，并且把 BlockId 作为参数发送给 Objective-C，Objective-C 收到参数时会创建 Block，调用完 Objective-C 函数后就会执行这个刚刚创建的 Block。</p>
<p>Objective-C 会向 Block 中传入参数和 BlockId，然后在 Block 内部调用 JavaScript 的方法，随后 JavaScript 查找到当时注册的 Block 并执行。</p>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="https://github.com/jackytianhappy/ImgSource/blob/master/ReactNative%E5%8E%9F%E7%90%86.png?raw=true" alt="Alta"></p>
<h1 id="React-Native-源码分析"><a href="#React-Native-源码分析" class="headerlink" title="React Native 源码分析"></a>React Native 源码分析</h1><p>要想深入理解 React Native 的工作原理，有两个部分有必要阅读一下，分别是初始化阶段和方法调用阶段。</p>
<h2 id="初始化React-Native"><a href="#初始化React-Native" class="headerlink" title="初始化React Native"></a>初始化React Native</h2><p>每个项目都有一个入口，然后进行初始化操作，React Native 也不例外。一个不含 Objective-C 代码的项目留给我们的唯一线索就是位于 AppDelegate 文件中的代码：</p>
<pre><code>RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation moduleName:@&quot;PropertyFinder&quot; initialProperties:nil launchOptions:launchOptions];    
</code></pre><p>用户能看到的一切内容都来源于这个 RootView，所有的初始化工作也都在这个方法内完成。</p>
<p>在这个方法内部，在创建 RootView 之前，React Native 实际上先创建了一个 Bridge 对象。它是 Objective-C 与 JavaScript 交互的桥梁，后续的方法交互完全依赖于它，而整个初始化过程的最终目的其实也就是创建这个桥梁对象。</p>
<p>初始化方法的核心是 setUp 方法，而 setUp 方法的主要任务则是创建 BatchedBridge。</p>
<p>BatchedBridge 的作用是批量读取 JavaScript 对 Objective-C 的方法调用，同时它内部持有一个 JavaScriptExecutor，顾名思义，这个对象用来执行 JavaScript 代码。</p>
<p>创建 BatchedBridge 的关键是 start 方法，它可以分为五个步骤：</p>
<ol>
<li>读取 JavaScript 源码</li>
<li>初始化模块信息</li>
<li>初始化 JavaScript 代码的执行器，即 RCTJSCExecutor 对象</li>
<li>生成模块列表并写入 JavaScript 端</li>
<li>执行 JavaScript 源码</li>
</ol>
<h3 id="读取-JavaScript-源码"><a href="#读取-JavaScript-源码" class="headerlink" title="读取 JavaScript 源码"></a>读取 JavaScript 源码</h3><p>这一部分的具体代码实现没有太大的讨论意义。我们只要明白，JavaScript 的代码是在 Objective-C 提供的环境下运行的，所以第一步就是把 JavaScript 加载进内存中，对于一个空的项目来说，所有的 JavaScript 代码大约占用 1.5 Mb 的内存空间。</p>
<p>需要说明的是，在这一步中，JSX 代码已经被转化成原生的 JavaScript 代码。</p>
<h3 id="初始化模块信息"><a href="#初始化模块信息" class="headerlink" title="初始化模块信息"></a>初始化模块信息</h3><p>这一步在方法 initModulesWithDispatchGroup: 中实现，主要任务是找到所有需要暴露给 JavaScript 的类。每一个需要暴露给 JavaScript 的类(也成为 Module，以下不作区分)都会标记一个宏：RCT_EXPORT_MODULE，这个宏的具体实现并不复杂：</p>
<pre><code>#define RCT_EXPORT_MODULE(js_name) \
RCT_EXTERN void RCTRegisterModule(Class); \
+ (NSString *)moduleName { return @#js_name; } \
+ (void)load { RCTRegisterModule(self); }
</code></pre><p>这样，这个类在 load 方法中就会调用 RCTRegisterModule 方法注册自己：</p>
<pre><code>    void RCTRegisterModule(Class moduleClass)
{
  static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{
    RCTModuleClasses = [NSMutableArray new];
  });

  [RCTModuleClasses addObject:moduleClass];
}
</code></pre><p>因此，React Native 可以通过 RCTModuleClasses 拿到所有暴露给 JavaScript 的类。下一步操作是遍历这个数组，然后生成 RCTModuleData 对象：</p>
<pre><code>for (Class moduleClass in RCTGetModuleClasses()) {
    RCTModuleData *moduleData = [[RCTModuleData alloc]initWithModuleClass:moduleClass                                                                      bridge:self];
    [moduleClassesByID addObject:moduleClass];
    [moduleDataByID addObject:moduleData];
}
</code></pre><p>可以想见，RCTModuleData 对象是模块配置表的主要组成部分。如果把模块配置表想象成一个数组，那么每一个元素就是一个 RCTModuleData 对象。</p>
<p><a href="http://www.jianshu.com/p/978c4bd3a759" target="_blank" rel="external">参见原文地址</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/18/WKWebview和UIWebView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/18/WKWebview和UIWebView/" itemprop="url">
                  WKWebview和UIWebView
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-18T18:10:15+08:00">
                2017-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>开发App的过程中，常常会遇到在App内部加载网页，通常用UIWebView加载。加载速度慢，占用内存多，优化困难。如果加载网页多，还可能因为过量占用内存而给系统kill掉。各种优化的方法效果也不那么明显</p>
</blockquote>
<p>iOS8以后，苹果推出了新框架Wekkit，提供了替换UIWebView的组件WKWebView。各种UIWebView的问题没有了，速度更快了，占用内存少了，一句话，WKWebView是App内部加载网页的最佳选择！</p>
<p>WKWebView的特性：</p>
<ol>
<li>在性能、稳定性、功能方面有很大提升（最直观的体现就是加载网页是占用的内存，模拟器加载百度与开源中国网站时，WKWebView占用23M，而UIWebView占用85M）；</li>
<li>允许JavaScript的Nitro库加载并使用（UIWebView中限制）；</li>
<li>支持了更多的HTML5特性；</li>
<li>高达60fps的滚动刷新率以及内置手势；</li>
<li>将UIWebViewDelegate与UIWebView重构成了14类与3个协议（查看苹果官方文档）；</li>
</ol>
<p>从以下几个方面说下WKWebView的基本用法：</p>
<ol>
<li>加载网页</li>
<li>加载的状态回调</li>
<li>新的WKUIDelegate协议</li>
<li>动态加载并运行js代码</li>
<li>webView执行js代码</li>
<li>js调用App注册过的方法</li>
</ol>
<h2 id="UIWebView和WKWebView的比较和选择"><a href="#UIWebView和WKWebView的比较和选择" class="headerlink" title="UIWebView和WKWebView的比较和选择"></a>UIWebView和WKWebView的比较和选择</h2><p>WKWebView是苹果在WWDC2014发布会中发布IOS8的时候公布WebKit时候使用的新型的H5容器。它与UIWebView相比较，拥有更快的加载速度和性能，更低的内存占用。将UIWebViewDelegate和UIWebView重构成了14个类，3个协议，可以让开发者进行更加细致的配置。</p>
<p>但是他有一个最致命的缺陷，就是WKWebView的请求不能被NSURLProtocol截获。而我们团队开发的app中对于H5容器最佳的优化点主要就在于使用NSURLProtocol技术对于H5进行离线包的处理和H5的图片和Native的图片公用一套缓存的技术。因为该问题的存在，目前我们团队还没有使用WKWebView代替UIWebVIew。</p>
<h2 id="UIWebView的基本用法"><a href="#UIWebView的基本用法" class="headerlink" title="UIWebView的基本用法"></a>UIWebView的基本用法</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code>UIWebView *webView = [[UIWebView alloc] initWithFrame:self.view.bounds];
webView.delegate = self;
[self.view addSubview:webView];    //网络地址
NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.taobao.com&quot;];    NSURLRequest *request = [NSURLRequest requestWithURL:url];
[webView loadRequest:request];    
</code></pre><h3 id="UIWebViewDelegate常用的代理方法"><a href="#UIWebViewDelegate常用的代理方法" class="headerlink" title="UIWebViewDelegate常用的代理方法"></a>UIWebViewDelegate常用的代理方法</h3><pre><code>- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;//进行加载前的预判断，如果返回YES，则会进入后续流程（StartLoad,FinishLoad）。如果返回NO，这不会进入后续流程。
- (void)webViewDidStartLoad:(UIWebView *)webView;//开始加载网页
- (void)webViewDidFinishLoad:(UIWebView *)webView;//加载完成
- (void)webView:(UIWebView *)webView didFailLoadWithError:(nullable NSError *)error;//加载失败
</code></pre><h3 id="Native调用js中方法"><a href="#Native调用js中方法" class="headerlink" title="Native调用js中方法"></a>Native调用js中方法</h3><p>我们可以调用- (nullable NSString )stringByEvaluatingJavaScriptFromString:(NSString )script;函数进行js调用。</p>
<pre><code>[webView stringByEvaluatingJavaScriptFromString:@&quot;hello()&quot;];
[webView stringByEvaluatingJavaScriptFromString:@&quot;helloWithName(&apos;jack&apos;)&quot;];
</code></pre><h3 id="JS中调用Naitve的方法"><a href="#JS中调用Naitve的方法" class="headerlink" title="JS中调用Naitve的方法"></a>JS中调用Naitve的方法</h3><p>具体让js通知native进行方法调用，我们可以让js产生一个特殊的请求。可以让Native代码可以拦截到，而且不然用户察觉。业界一般的实现方案是在网页中加载一个隐藏的iframe来实现该功能。通过将iframe的src指定为一个特殊的URL，实现在- (BOOL)webView:(UIWebView )webView shouldStartLoadWithRequest:(NSURLRequest )request navigationType:(UIWebViewNavigationType)navigationType;方案中进行拦截处理。对应的js调用代码如下：</p>
<h2 id="WKWebView的基本用法"><a href="#WKWebView的基本用法" class="headerlink" title="WKWebView的基本用法"></a>WKWebView的基本用法</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><pre><code>WKWebView *webView = [[WKWebView alloc] initWithFrame:[UIScreen mainScreen].bounds];    NSURL *url = [NSURL URLWithString:@&quot;http://www.taobao.com&quot;];    NSURLRequest *request = [NSURLRequest requestWithURL:url];
[webView loadRequest:request];
[self.view addSubview:webView];
</code></pre><h3 id="常用代理方法"><a href="#常用代理方法" class="headerlink" title="常用代理方法"></a>常用代理方法</h3><pre><code>/**
 *  根据webView、navigationAction相关信息决定这次跳转是否可以继续进行,这些信息包含HTTP发送请求，如头部包含User-Agent,Accept,refer
 *  在发送请求之前，决定是否跳转的代理
 *  @param webView
 *  @param navigationAction
 *  @param decisionHandler
 */- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler{
    decisionHandler(WKNavigationActionPolicyAllow);
}/**
 *  这个代理方法表示当客户端收到服务器的响应头，根据response相关信息，可以决定这次跳转是否可以继续进行。
 *  在收到响应后，决定是否跳转的代理
 *  @param webView
 *  @param navigationResponse
 *  @param decisionHandler
 */- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler{
    decisionHandler(WKNavigationResponsePolicyAllow);
}/**
 *  准备加载页面。等同于UIWebViewDelegate: - webView:shouldStartLoadWithRequest:navigationType
 *
 *  @param webView
 *  @param navigation
 */- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation{
}/**
 *  这个代理是服务器redirect时调用
 *  接收到服务器跳转请求的代理
 *  @param webView
 *  @param navigation
 */- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation{

}

- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error{

}/**
 *  内容开始加载. 等同于UIWebViewDelegate: - webViewDidStartLoad:
 *
 *  @param webView
 *  @param navigation
 */- (void)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation{

}/**
 *  页面加载完成。 等同于UIWebViewDelegate: - webViewDidFinishLoad:
 *
 *  @param webView
 *  @param navigation
 */- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation{

}/**
 *  页面加载失败。 等同于UIWebViewDelegate: - webView:didFailLoadWithError:
 *
 *  @param webView
 *  @param navigation
 *  @param error      
 */- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error{

}

- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView NS_AVAILABLE(10_11, 9_0){

}/*
 我们看看WKUIDelegate的几个代理方法，虽然不是必须实现的，但是如果我们的页面中有调用了js的alert、confirm、prompt方法，我们应该实现下面这几个代理方法，然后在原来这里调用native的弹出窗，因为使用WKWebView后，HTML中的alert、confirm、prompt方法调用是不会再弹出窗口了，只是转化成ios的native回调代理方法
 */#pragma mark - WKUIDelegate- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler{    UIAlertController *alertView = [UIAlertController alertControllerWithTitle:@&quot;h5Container&quot; message:message preferredStyle:UIAlertControllerStyleAlert];//    [alertView addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) {//        textField.textColor = [UIColor redColor];//    }];
    [alertView addAction:[UIAlertAction actionWithTitle:@&quot;我很确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        completionHandler();
    }]];
    [self presentViewController:alertView animated:YES completion:nil];
}
</code></pre><h3 id="Native调用JS中的方法"><a href="#Native调用JS中的方法" class="headerlink" title="Native调用JS中的方法"></a>Native调用JS中的方法</h3><p>WKWebView提供的调用js代码的函数是：</p>
<pre><code>- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ __nullable)(__nullable id, NSError * __nullable error))completionHandler;
</code></pre><p>比如我们在加载的HTML文件中有如下js代码：</p>
<pre><code>function hello(){
alert(&quot;你好！&quot;);
}function helloWithName(name){
alert(name + &quot;，你好！&quot;);
}
</code></pre><p>我们可以调用如下代码进行js的调用</p>
<pre><code>[_wkView evaluateJavaScript:@&quot;hello()&quot; completionHandler:^(id item, NSError * error) {
</code></pre><p>}];</p>
<pre><code>[_wkView evaluateJavaScript:@&quot;helloWithName(&apos;jack&apos;)&quot;     completionHandler:^(id item, NSError *error) {

    }];
</code></pre><p>同UIWebView一样，我们也可以通过字符串的形式进行js调用。</p>
<pre><code>NSString *jsString = @&quot;function sayHello(){ \
                                alert(&apos;jack11&apos;)   \
                            }                   \
                           sayHello()&quot;;
[_wkView evaluateJavaScript:jsString completionHandler:^(id item, NSError *error) {

}];

jsString = @&quot; var p = document.createElement(&apos;p&apos;); \
p.innerText = &apos;New Line&apos;;            \
document.body.appendChild(p);        \
&quot;;
[_wkView evaluateJavaScript:jsString completionHandler:^(id item, NSError *error) {

}];
</code></pre><h3 id="JS中调用Naitve的方法-1"><a href="#JS中调用Naitve的方法-1" class="headerlink" title="JS中调用Naitve的方法"></a>JS中调用Naitve的方法</h3><p>除了和UIWebView加载一个隐藏的ifame之外，WKWebView自身还提供了一套js调用native的规范。</p>
<p>我们可以在初始化WKWebView的时候，给他设置一个config参数。</p>
<pre><code>//高端配置
//创建配置
WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];    //创建UserContentController(提供javaScript向webView发送消息的方法)
WKUserContentController *userContent = [[WKUserContentController alloc] init];    //添加消息处理，注意：self指代的是需要遵守WKScriptMessageHandler协议，结束时需要移除
[userContent addScriptMessageHandler:self name:@&quot;NativeMethod&quot;];    //将UserContentController设置到配置文件中
config.userContentController = userContent;    //高端的自定义配置创建WKWebView
_wkView = [[YXWKView alloc] initWithFrame:self.view.bounds configuration:config];    NSURL *url = [NSURL URLWithString:@&quot;http://localhost:8080/myDiary/index.html&quot;];    NSURLRequest *request = [NSURLRequest requestWithURL:url];
[_wkView loadRequest:request];
_wkView.UIDelegate = self;
_wkView.navigationDelegate = self;
[self.view addSubview:_wkView];
</code></pre><p> 我们在js可以通过NativeMethod这个Handler让js代码调用native。</p>
<p>比如在js代码中，我新增了一个方法</p>
<pre><code>function invokeNativeMethod(){        
window.webkit.messageHandlers.NativeMethod.postMessage(&quot;我要调用native的方法&quot;);
}
</code></pre><p>触发以上方法的时候，会在native以下方法中进行拦截处理。</p>
<pre><code>- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message{    //这里就是使用高端配置，js调用native的处理地方。我们可以根据name和body，进行桥协议的处理。
    NSString *messageName = message.name;    
    if ([@&quot;NativeMethod&quot; isEqualToString:messageName]) {        
    id messageBody = message.body;        
    NSLog(@&quot;%@&quot;,messageBody);
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/12/多线程以及多线程锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/12/多线程以及多线程锁/" itemprop="url">
                  多线程以及多线程锁
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T17:25:30+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="多线程中常用的锁"><a href="#多线程中常用的锁" class="headerlink" title="多线程中常用的锁"></a>多线程中常用的锁</h1><h2 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h2><p>lock unlock</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h2><pre><code>- (void)getIamgeName:(int)index{
    NSString *imageName;
    @synchronized(self) {
        if (imageNames.count&gt;0) {
            imageName = [imageNames lastObject];
            [imageNames removeObject:imageName];
        }
    }
}    
</code></pre><h2 id="条件信号量dispatch-semaphore-t"><a href="#条件信号量dispatch-semaphore-t" class="headerlink" title="条件信号量dispatch_semaphore_t"></a>条件信号量dispatch_semaphore_t</h2><blockquote>
<p>GCD中信号量，也可以解决资源抢占问题,支持信号通知和信号等待。每当发送一个信号通知，则信号量+1；每当发送一个等待信号时信号量-1,；如果信号量为0则信号会处于等待状态，直到信号量大于0开始执行。</p>
</blockquote>
<h2 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h2><p>NSCondition同样实现了NSLocking协议，所以它和NSLock一样，也有NSLocking协议的lock和unlock方法，可以当做NSLock来使用解决线程同步问题，用法完全一样</p>
<h2 id="条件锁NSConditionLock"><a href="#条件锁NSConditionLock" class="headerlink" title="条件锁NSConditionLock"></a>条件锁NSConditionLock</h2><p>也有人说这是个互斥锁NSConditionLock同样实现了NSLocking协议，试验过程中发现性能很低</p>
<h2 id="递归锁NSRecursiveLock"><a href="#递归锁NSRecursiveLock" class="headerlink" title="递归锁NSRecursiveLock"></a>递归锁NSRecursiveLock</h2><p>有时候“加锁代码”中存在递归调用，递归开始前加锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁，这个时候可以使用递归锁来解决。使用递归锁可以在一个线程中反复获取锁而不造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被最终释放。</p>
<h2 id="NSDistributedLock"><a href="#NSDistributedLock" class="headerlink" title="NSDistributedLock"></a>NSDistributedLock</h2><p>NSDistributedLock是MAC开发中的跨进程的分布式锁，底层是用文件系统实现的互斥锁。NSDistributedLock没有实现NSLocking协议，所以没有lock方法，取而代之的是非阻塞的tryLock方法。</p>
<pre><code>NSDistributedLock *lock = [[NSDistributedLock alloc]             initWithPath:@&quot;/Users/mac/Desktop/lock.lock&quot;];
    while (![lock tryLock])
    {
        sleep(1);
    }

    //do something
    [lock unlock];
</code></pre><h2 id="互斥锁POSIX"><a href="#互斥锁POSIX" class="headerlink" title="互斥锁POSIX"></a>互斥锁POSIX</h2><p>POSIX和dispatch_semaphore_t很像，但是完全不同。POSIX是Unix/Linux平台上提供的一套条件互斥锁的API。<br>新建一个简单的POSIX互斥锁，引入头文件#import <pthread.h>声明并初始化一个pthread_mutex_t的结构。使用pthread_mutex_lock和pthread_mutex_unlock函数。调用pthread_mutex_destroy来释放该锁的数据结构。</pthread.h></p>
<h2 id="GCD线程阻断dispatch-barrier-async-dispatch-barrier-sync"><a href="#GCD线程阻断dispatch-barrier-async-dispatch-barrier-sync" class="headerlink" title="GCD线程阻断dispatch_barrier_async/dispatch_barrier_sync"></a>GCD线程阻断dispatch_barrier_async/dispatch_barrier_sync</h2><p>dispatch_barrier_async/dispatch_barrier_sync在一定的基础上也可以做线程同步，会在线程队列中打断其他线程执行当前任务，也就是说只有用在并发的线程队列中才会有效，因为串行队列本来就是一个一个的执行的，你打断执行一个和插入一个是一样的效果。两个的区别是是否等待任务执行完成。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/12/Block内存地址/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/12/Block内存地址/" itemprop="url">
                  __Block内存地址
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T15:47:10+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>为什么添加__block的外部变量在闭包内部能够被修改？</p>
</blockquote>
<pre><code>int a = 0;          //栈区
void (^foo)(void) = ^{ 
   NSlog(@&quot;%@&quot;,a);   //堆区
};
foo(); 
//这里，a的值被修改为1
</code></pre><p>需要修改a的值</p>
<pre><code>__block int a = 0;
NSLog(@&quot;定义前：%p&quot;, &amp;a);         //栈区
void (^foo)(void) = ^{
    a = 1;
    NSLog(@&quot;block内部：%p&quot;, &amp;a);    //堆区
};
NSLog(@&quot;定义后：%p&quot;, &amp;a);         //堆区
foo();
</code></pre><p>添加<strong>block之后，变量a会被拷贝到堆区，同时经过编译之后生成一个</strong>forwarding的指针，这个指针指向的变量原栈区，修改时，实际上是通过<strong>forwarding指针访问堆区的内容进行修改。这样实现了修改。不加</strong>block不允许修改的实际上是变量的在栈中的指针地址。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/12/iOS内存泄漏工具以及实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/12/iOS内存泄漏工具以及实现原理/" itemprop="url">
                  以及实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T14:25:31+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="检测原理或实现思路"><a href="#检测原理或实现思路" class="headerlink" title="检测原理或实现思路"></a>检测原理或实现思路</h1><blockquote>
<p>开源库 例如 HeapInspector-for-iOS 和 MSLeakHunter。</p>
</blockquote>
<p>HeapInspector-for-iOS 可以说是 Allocations 的改进。它通过 hook 掉 alloc，dealloc，retain，release 等方法，来记录对象的生命周期。具体的检测内存泄露的方法和原理，与 Instrument 的 Allocations 一致。然而它跟 Allocations 一样，存在的问题是，你需要一个个场景去重复的操作，还有检测不及时。</p>
<p>MSLeakHunter 就简单得多，它只检测 UIViewController 和 UIView，通过 hook 掉 UIViewController 的 -viewDidDisappear: 方法，并认为 -viewDidDisappear: 后，UIViewController 将很快被释放，如果 UIViewController 没有被释放，则打个建议日志。这种做法其实不是很好，-viewDidDisappear: 被调用可能是因为又 push 进来一个新的 ViewController，把当前的 ViewController 挡住了，所以可能有很多错误的建议，需要结合你实际的操作去具体地分析日志。</p>
<p>#MLeaksFinder原理<br>MLeaksFinder 一开始从 UIViewController 入手。我们知道，当一个 UIViewController 被 pop 或 dismiss 后，该 UIViewController 包括它的 view，view 的 subviews 等等将很快被释放（除非你把它设计成单例，或者持有它的强引用，但一般很少这样做）。于是，我们只需在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 UIViewController，它的 view，view 的 subviews 等等是否还存在。</p>
<p>具体的方法是，为基类 NSObject 添加一个方法 -willDealloc 方法，该方法的作用是，先用一个弱指针指向 self，并在一小段时间(3秒)后，通过这个弱指针调用 -assertNotDealloc，而 -assertNotDealloc 主要作用是直接中断言。</p>
<pre><code>- (BOOL)willDealloc {
    __weak id weakSelf = self;
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        [weakSelf assertNotDealloc];
    });
    return YES;
}
- (void)assertNotDealloc {
     NSAssert(NO, @“”);
}
</code></pre><p>这样，当我们认为某个对象应该要被释放了，在释放前调用这个方法，如果3秒后它被释放成功，weakSelf 就指向 nil，不会调用到 -assertNotDealloc 方法，也就不会中断言，如果它没被释放（泄露了），-assertNotDealloc 就会被调用中断言。这样，当一个 UIViewController 被 pop 或 dismiss 时（我们认为它应该要被释放了），我们遍历该 UIViewController 上的所有 view，依次调 -willDealloc，若3秒后没被释放，就会中断言。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/06/Runloop详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/06/Runloop详解/" itemprop="url">
                  Runloop详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-06T14:22:17+08:00">
                2017-04-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Runloop实现了自动释放，延迟回调，触摸事件，屏幕刷新等功能。</p>
</blockquote>
<h2 id="Runloop概念"><a href="#Runloop概念" class="headerlink" title="Runloop概念"></a>Runloop概念</h2><ol>
<li><p>NSRunLoop是iOS消息机制的处理模式:<br><br>NSRunLoop的主要作用：控制NSRunLoop里面线程的执行和休眠，在有事情做的时候使当前NSRunLoop控制的线程工作，没有事情做让当前NSRunLoop的控制的线程休眠。</p>
</li>
<li><p>NSRunLoop 就是一直在循环检测，从线程start到线程end，检测inputsource(如点击，双击等操作)同步事件，检测timesource同步事件，检测到输入源会执行处理函数，首先会产生通知，corefunction向线程添加runloop observers来监听事件，意在监听事件发生时来做处理。</p>
</li>
<li><p>runloopmode是一个集合，包括监听：事件源，定时器，以及需通知的runloop observers,模式包括：<br></p>
<p> default模式：几乎包括所有输入源(除NSConnection) NSDefaultRunLoopMode模式</p>
<p> Modal模式：处理modal panels事件,需要等待处理的input source为modal panel时设置，比如NSSavePanel和NSOpenPanel。</p>
<p> connection模式：处理NSConnection事件，属于系统内部，用户基本不用</p>
<p> event tracking模式：使用该模式来处理用户界面相关的事件,例如在拖动loop或其他user interface tracking loops时处于此种模式下，在此模式下会限制输入事件的处理。例如，当手指按住UITableView拖动时就会处于此模式</p>
<p> common modes模式：这是一个伪模式，其为一组run loop mode的集合，将输入源加入此模式意味着在Common Modes中包含的所有模式下都可以处理。在Cocoa应用程序中，默认情况下Common Modes包含default modes,modal modes,event Tracking modes, 可使用CFRunLoopAddCommonMode方法向Common Modes中添加自定义modes。</p>
</li>
</ol>
<p>注意这个并不是一个特定的mode，而是一个mode的集合，而runloop必须运行在一个特定的mode下。</p>
<ol>
<li>每次运行一个run loop，你指定（显式或隐式）run loop的运行模式。当相应的模式传递给run loop时，只有与该模式对应的 input sources才被监控并允许run loop对事件进行处理（与此类似，也只有与该模式对应的observers才会被通知）</li>
<li>子线程中的NSRunLoop需要手动启动，在子线程中使用timer要启动NSRunLoop。</li>
</ol>
<p><a href="http://blog.wangruofeng007.com/blog/2016/01/12/runloopxiang-jie/" target="_blank" rel="external">这里有篇不错的文章</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/05/iOS中图片的解压缩详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacky Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jakcy’s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/05/iOS中图片的解压缩详解/" itemprop="url">
                  性能优化-iOS中图片的解压缩
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-05T16:20:54+08:00">
                2017-04-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="图片加载的工作流"><a href="#图片加载的工作流" class="headerlink" title="图片加载的工作流"></a>图片加载的工作流</h2><ol>
<li>假设我们使用 +imageWithContentsOfFile: 方法从磁盘中加载一张图片，这个时候的图片并没有解压缩；</li>
<li>然后将生成的 UIImage 赋值给 UIImageView ；</li>
<li>接着一个隐式的 CATransaction 捕获到了 UIImageView 图层树的变化；</li>
<li>在主线程的下一个 run loop 到来时，Core Animation 提交了这个隐式的 transaction ，这个过程可能会对图片进行 copy 操作，而受图片是否字节对齐等因素的影响，这个 copy 操作可能会涉及以下部分或全部步骤：<br><br> a. 分配内存缓冲区用于管理文件 IO 和解压缩操作<br><br> b. 将文件数据从磁盘读到内存中<br><br> c. 将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作<br><br> d. 最后 Core Animation 使用未压缩的位图数据渲染 UIImageView 的图层<br><br>图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。</li>
</ol>
<h2 id="为什么需要解压缩"><a href="#为什么需要解压缩" class="headerlink" title="为什么需要解压缩"></a>为什么需要解压缩</h2><p>图片的解压缩需要消耗大量的 CPU 时间，那么我们为什么还要对图片进行解压缩呢？是否可以不经过解压缩，而直接将图片显示到屏幕上呢？答案是否定的。要想弄明白这个问题，我们首先需要知道什么是位图：<br><br>位图：位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点。我们在应用中经常用到的 JPEG 和 PNG 图片就是位图。下面，我们来看一个具体的例子，这是一张 PNG 图片，像素为 30 × 30 ，文件大小为 843B ：<br><br>图片设置方式：</p>
<pre><code>UIImage *image = [UIImage imageNamed:@&quot;check_green&quot;];
CFDataRef rawData = CGDataProviderCopyData(CGImageGetDataProvider(image.CGImage));
</code></pre><p>获取到的图片原始数据为，大小为3600B</p>
<pre><code>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
01020102 032c023c 0567048c 078d06bf 08a006d9 09b307f3 09b307f3 08a006d9 078d06bf
0567048c 032c023c 01020102 00000000 00000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000 01060108 05570476 09ab07e9 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff
09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09ab07e9 05570476 01060108 00000000
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 033d0353 08a607e2 09bb07ff 09bb07ff 09bb07ff 09bb07ff
...
09bb07ff 09bb07ff 09bb07ff 09bb07ff 08a607e2 033d0353 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000 01060108 05570476 09ab07e9 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff
09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09ab07e9 05570476 01060108 00000000
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000000 00000000 01020102 032c023c 0567048c
078d06bf 08a006d9 09b307f3 09b307f3 08a006d9 078d06bf 0567048c 032c023c 01020102
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
</code></pre><p>这张文件大小为 843B 的 PNG 图片解压缩后的大小是 3600B ，是原始文件大小的 4.27 倍。那么这个 3600B 是怎么得来的呢？与图片的文件大小或者像素有什么必然的联系吗？事实上，解压缩后的图片大小与原始文件大小之间没有任何关系，而只与图片的像素有关：</p>
<pre><code>解压缩后的图片大小 = 图片的像素宽 30 * 图片的像素高 30 * 每个像素所占的字节数 4
</code></pre><p>事实上，<b>不管是 JPEG 还是 PNG 图片，都是一种压缩的位图图形格式。</b>只不过 PNG 图片是无损压缩，并且支持 alpha 通道，而 JPEG 图片则是有损压缩，可以指定 0-100% 的压缩比。值得一提的是，在苹果的 SDK 中专门提供了两个函数用来生成 PNG 和 JPEG 图片：</p>
<pre><code>// return image as PNG. May return nil if image has no CGImageRef or invalid bitmap format
UIKIT_EXTERN NSData * __nullable UIImagePNGRepresentation(UIImage * __nonnull image);

// return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)                           
UIKIT_EXTERN NSData * __nullable UIImageJPEGRepresentation(UIImage * __nonnull image, CGFloat compressionQuality);
</code></pre><p>在将磁盘中的图片渲染到屏幕之前，必须先要得到图片的原始像素数据，才能执行后续的绘制操作，这就是为什么需要对图片解压缩的原因。</p>
<h2 id="强制解压缩的原理"><a href="#强制解压缩的原理" class="headerlink" title="强制解压缩的原理"></a>强制解压缩的原理</h2><p>图片的解压缩不可避免，而我们也不想让它在主线程执行，影响我们应用的响应性，那么是否有比较好的解决方案呢？答案是肯定的。<br></p>
<p>前面已经提到了，当未解压缩的图片将要渲染到屏幕时，系统会在主线程对图片进行解压缩，而如果图片已经解压缩了，系统就不会再对图片进行解压缩。因此，也就有了业内的解决方案，在子线程提前对图片进行强制解压缩。<br></p>
<p>而强制解压缩的原理就是对图片进行重新绘制，得到一张新的解压缩后的位图。其中，用到的最核心的函数是 CGBitmapContextCreate ：<br></p>
<pre><code>/* Create a bitmap context. The context draws into a bitmap which is `width&apos;
   pixels wide and `height&apos; pixels high. The number of components for each
   pixel is specified by `space&apos;, which may also specify a destination color
   profile. The number of bits for each component of a pixel is specified by
   `bitsPerComponent&apos;. The number of bytes per pixel is equal to
   `(bitsPerComponent * number of components + 7)/8&apos;. Each row of the bitmap
   consists of `bytesPerRow&apos; bytes, which must be at least `width * bytes
   per pixel&apos; bytes; in addition, `bytesPerRow&apos; must be an integer multiple
   of the number of bytes per pixel. `data&apos;, if non-NULL, points to a block
   of memory at least `bytesPerRow * height&apos; bytes. If `data&apos; is NULL, the
   data for context is allocated automatically and freed when the context is
   deallocated. `bitmapInfo&apos; specifies whether the bitmap should contain an
   alpha channel and how it&apos;s to be generated, along with whether the
   components are floating-point or integer. */
CG_EXTERN CGContextRef __nullable CGBitmapContextCreate(void * __nullable data,
    size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow,
    CGColorSpaceRef cg_nullable space, uint32_t bitmapInfo)
    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
</code></pre><p>这个函数用于创建一个位图上下文，用来绘制一张宽 width 像素，高 height 像素的位图。这个函数的注释比较长，参数也比较难理解，但是先别着急，我们先来了解下相关的知识，然后再回过头来理解这些参数，就会比较简单了。</p>
<h3 id="Pixel-Format"><a href="#Pixel-Format" class="headerlink" title="Pixel Format"></a>Pixel Format</h3><p>位图其实就是一个像素数组，而像素格式则是用来描述每个像素的组成格式，它包括以下信息：</p>
<ol>
<li>Bits per component ：一个像素中每个独立的颜色分量使用的 bit 数；</li>
<li>Bits per pixel ：一个像素使用的总 bit 数；</li>
<li>Bytes per row ：位图中的每一行使用的字节数。</li>
</ol>
<p>有一点需要注意的是，对于位图来说，像素格式并不是随意组合的，目前只支持以下有限的 17 种特定组合：<br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/Supported%20Pixel%20Formats.png?raw=true" alt="Alta Text"></p>
<p>从上图可知，对于 iOS 来说，只支持 8 种像素格式。其中颜色空间为 Null 的 1 种，Gray 的 2 种，RGB 的 5 种，CMYK 的 0 种。换句话说，iOS 并不支持 CMYK 的颜色空间。另外，在表格的第 2 列中，除了像素格式外，还指定了 bitmap information constant ，我们在后面会详细介绍。</p>
<h3 id="Color-and-Color-Spaces"><a href="#Color-and-Color-Spaces" class="headerlink" title="Color and Color Spaces"></a>Color and Color Spaces</h3><p>上面我们提到了颜色空间，那么什么是颜色空间呢？它跟颜色有什么关系呢？在 Quartz 中，一个颜色是由一组值来表示的，比如 0, 0, 1 。而颜色空间则是用来说明如何解析这些值的，离开了颜色空间，它们将变得毫无意义。<br></p>
<p>如果不知道颜色空间，那么我们根本无法知道这些值所代表的颜色。比如 0, 0, 1 在 RGB 下代表蓝色，而在 BGR 下则代表的是红色。在 RGB 和 BGR 两种颜色空间下，绿色是相同的，而红色和蓝色则相互对调了。因此，对于同一张图片，使用 RGB 和 BGR 两种颜色空间可能会得到两种不一样的效果<br></p>
<h3 id="Color-Spaces-and-Bitmap-Layout"><a href="#Color-Spaces-and-Bitmap-Layout" class="headerlink" title="Color Spaces and Bitmap Layout"></a>Color Spaces and Bitmap Layout</h3><p>像素格式是用来描述每个像素的组成格式的，比如每个像素使用的总 bit 数。而要想确保 Quartz 能够正确地解析这些 bit 所代表的含义，我们还需要提供位图的布局信息 CGBitmapInfo ：</p>
<pre><code>typedef CF_OPTIONS(uint32_t, CGBitmapInfo) {
    kCGBitmapAlphaInfoMask = 0x1F,

    kCGBitmapFloatInfoMask = 0xF00,
    kCGBitmapFloatComponents = (1 &lt;&lt; 8),

    kCGBitmapByteOrderMask     = kCGImageByteOrderMask,
    kCGBitmapByteOrderDefault  = (0 &lt;&lt; 12),
    kCGBitmapByteOrder16Little = kCGImageByteOrder16Little,
    kCGBitmapByteOrder32Little = kCGImageByteOrder32Little,
    kCGBitmapByteOrder16Big    = kCGImageByteOrder16Big,
    kCGBitmapByteOrder32Big    = kCGImageByteOrder32Big
} CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
</code></pre><p>它主要提供了三个方面的布局信息：</p>
<ol>
<li>它主要提供了三个方面的布局信息：</li>
<li>颜色分量是否为浮点数；</li>
<li>像素格式的字节顺序。</li>
</ol>
<p>其中，alpha 的信息由枚举值 CGImageAlphaInfo 来表示：</p>
<pre><code>typedef CF_ENUM(uint32_t, CGImageAlphaInfo) {
    kCGImageAlphaNone,               /* For example, RGB. */
    kCGImageAlphaPremultipliedLast,  /* For example, premultiplied RGBA */
    kCGImageAlphaPremultipliedFirst, /* For example, premultiplied ARGB */
    kCGImageAlphaLast,               /* For example, non-premultiplied RGBA */
    kCGImageAlphaFirst,              /* For example, non-premultiplied ARGB */
    kCGImageAlphaNoneSkipLast,       /* For example, RBGX. */
    kCGImageAlphaNoneSkipFirst,      /* For example, XRGB. */
    kCGImageAlphaOnly                /* No color data, alpha data only */
};
</code></pre><p>上面的注释其实已经比较清楚了，它同样也提供了三个方面的 alpha 信息:</p>
<ol>
<li>是否包含 alpha ；</li>
<li>如果包含 alpha ，那么 alpha 信息所处的位置，在像素的最低有效位，比如 RGBA ，还是最高有效位，比如 ARGB ；</li>
<li>如果包含 alpha ，那么每个颜色分量是否已经乘以 alpha 的值，这种做法可以加速图片的渲染时间，因为它避免了渲染时的额外乘法运算。比如，对于 RGB 颜色空间，用已经乘以 alpha 的数据来渲染图片，每个像素都可以避免 3 次乘法运算，红色乘以 alpha ，绿色乘以 alpha 和蓝色乘以 alpha 。<br></li>
</ol>
<p>那么我们在解压缩图片的时候应该使用哪个值呢？根据<a href="http://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use" target="_blank" rel="external">Which CGImageAlphaInfo should we use</a>和官方文档中对 UIGraphicsBeginImageContextWithOptions 函数的讨论：<br></p>
<p>我们可以知道，当图片不包含 alpha 的时候使用 kCGImageAlphaNoneSkipFirst ，否则使用 kCGImageAlphaPremultipliedFirst 。另外，这里也提到了字节顺序应该使用 32 位的主机字节顺序 kCGBitmapByteOrder32Host ，而这个值具体是什么，我们后面再讨论。</p>
<p>至于颜色分量是否为浮点数，这个就比较简单了，直接逻辑或 kCGBitmapFloatComponents 就可以了。更详细的内容就不展开了，因为我们一般用不上这个值。</p>
<p>接下来，我们来简单地了解下像素格式的<a href="https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/ByteOrdering.html#//apple_ref/doc/uid/20001150-CJBEJBHH" target="_blank" rel="external">字节顺序</a>，它是由枚举值 <code>CGImageByteOrderInfo</code> 来表示的：</p>
<pre><code>typedef CF_ENUM(uint32_t, CGImageByteOrderInfo) {
    kCGImageByteOrderMask     = 0x7000,
    kCGImageByteOrder16Little = (1 &lt;&lt; 12),
    kCGImageByteOrder32Little = (2 &lt;&lt; 12),
    kCGImageByteOrder16Big    = (3 &lt;&lt; 12),
    kCGImageByteOrder32Big    = (4 &lt;&lt; 12)
} CG_AVAILABLE_STARTING(__MAC_10_12, __IPHONE_10_0);
</code></pre><p>它主要提供了两个方面的字节顺序信息：</p>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.B0.8F.E7.AB.AF.E5.BA.8F" target="_blank" rel="external">小端模式</a>还是<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.A4.A7.E7.AB.AF.E5.BA.8F" target="_blank" rel="external">大端模式</a>；</li>
<li>数据以 16 位还是 32 位为单位。</li>
</ol>
<p>对于 iPhone 来说，采用的是小端模式，但是为了保证应用的向后兼容性，我们可以使用系统提供的宏，来避免 <a href="https://en.wikipedia.org/wiki/Hard_coding" target="_blank" rel="external">Hardcoding</a></p>
<pre><code>#ifdef __BIG_ENDIAN__
    #define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Big
    #define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Big
#else /* Little endian. */
    #define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Little
    #define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Little
#endif
</code></pre><p>根据前面的讨论，我们知道字节顺序的值应该使用的是 32 位的主机字节顺序 <code>kCGBitmapByteOrder32Host</code> ，这样的话不管当前设备采用的是小端模式还是大端模式，字节顺序始终与其保持一致。</p>
<p>下面，我们来看一张图，它非常形象地展示了在使用 16 或 32 位像素格式的 CMYK 和 RGB 颜色空间下，一个像素是如何被表示的：<br><img src="https://github.com/jackytianhappy/ImgSource/blob/master/pixel%20formats.png?raw=true" alt="Alta Text"></p>
<p>我们从图中可以看出，在 32 位像素格式下，每个颜色分量使用 8 位；而在 16 位像素格式下，每个颜色分量则使用 5 位。</p>
<p>好了，了解完这些相关知识后，我们再回过头来看看 <code>CGBitmapContextCreate</code> 函数中每个参数所代表的具体含义：</p>
<ol>
<li><code>data</code> ：如果不为 <code>NULL</code> ，那么它应该指向一块大小至少为 <code>bytesPerRow * height</code> 字节的内存；如果 为 <code>NULL</code> ，那么系统就会为我们自动分配和释放所需的内存，所以一般指定 <code>NULL</code> 即可；</li>
<li><code>width</code> 和 <code>height</code> ：位图的宽度和高度，分别赋值为图片的像素宽度和像素高度即可；</li>
<li><code>bitsPerComponent</code> ：像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可；</li>
<li><code>bytesPerRow</code> ：位图的每一行使用的字节数，大小至少为 <code>width * bytes per pixel</code> 字节。有意思的是，当我们指定<code>0</code> 时，系统不仅会为我们自动计算，而且还会进行 cache line alignment 的优化，更多信息可以查看 <a href="http://stackoverflow.com/questions/23790837/what-is-byte-alignment-cache-line-alignment-for-core-animation-why-it-matters" target="_blank" rel="external">what is byte alignment (cache line alignment) for Core Animation? Why it matters?</a> 和 <a href="http://stackoverflow.com/questions/15935074/why-is-my-images-bytes-per-row-more-than-its-bytes-per-pixel-times-its-width" target="_blank" rel="external">Why is my image’s Bytes per Row more than its Bytes per Pixel times its Width?</a> ，亲测可用；</li>
<li><code>space</code> ：就是我们前面提到的颜色空间，一般使用 RGB 即可；</li>
<li><code>bitmapInfo</code> ：就是我们前面提到的位图的布局信息</li>
</ol>
<h2 id="开源库的实现"><a href="#开源库的实现" class="headerlink" title="开源库的实现"></a>开源库的实现</h2><p>三个比较流行的开源库 <a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">YYKit</a> 、<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a> 和 <a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="external">FLAnimatedImage</a> 中，对图片的强制解压缩是如何实现的。</p>
<p> YYKit 中的相关代码，用于解压缩图片的函数 YYCGImageCreateDecodedCopy 存在于 YYImageCoder 类中，核心代码如下：</p>
<pre><code> CGImageRef YYCGImageCreateDecodedCopy(CGImageRef imageRef, BOOL decodeForDisplay) {
    ...

    if (decodeForDisplay) { // decode with redraw (may lose some precision)
        CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef) &amp; kCGBitmapAlphaInfoMask;

        BOOL hasAlpha = NO;
        if (alphaInfo == kCGImageAlphaPremultipliedLast ||
            alphaInfo == kCGImageAlphaPremultipliedFirst ||
            alphaInfo == kCGImageAlphaLast ||
            alphaInfo == kCGImageAlphaFirst) {
            hasAlpha = YES;
        }

        // BGRA8888 (premultiplied) or BGRX8888
        // same as UIGraphicsBeginImageContext() and -[UIView drawRect:]
        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;
        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;

        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);
        if (!context) return NULL;

        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); // decode
        CGImageRef newImage = CGBitmapContextCreateImage(context);
        CFRelease(context);

        return newImage;
    } else {
        ...
    }
}
</code></pre><p>它接受一个原始的位图参数 <code>imageRef</code> ，最终返回一个新的解压缩后的位图 <code>newImage</code> ，中间主要经过了以下三个步骤：<br></p>
<ol>
<li>使用 <code>CGBitmapContextCreate</code> 函数创建一个位图上下文；</li>
<li>使用 <code>CGContextDrawImage</code> 函数将原始位图绘制到上下文中；</li>
<li>使用 <code>CGBitmapContextCreateImage</code> 函数创建一张新的解压缩后的位图。</li>
</ol>
<p>事实上，SDWebImage 和 FLAnimatedImage 中对图片的解压缩过程与上述完全一致，只是传递给 <code>CGBitmapContextCreate</code> 函数的部分参数存在细微的差别，如下表所示：<br><img src="https://raw.githubusercontent.com/jackytianhappy/ImgSource/0619b8810cde373c9f061ad8843406f38285c56d/CGBitmapContextCreate.png" alt="Alta Text"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Jacky Tian" />
          <p class="site-author-name" itemprop="name">Jacky Tian</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jacky Tian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  






  





  

  

  

  

</body>
</html>
